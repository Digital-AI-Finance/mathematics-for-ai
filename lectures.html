<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lecture Proposals -- Mathematics for AI</title>

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <!-- KaTeX CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">

  <!-- Shared stylesheet (root-relative path) -->
  <link rel="stylesheet" href="css/style.css">

  <style>
    /* ---- Page-specific styles for lectures.html ---- */

    /* Version badge (not in shared CSS) */
    .plan-hero .version-badge {
      display: inline-block;
      padding: var(--space-xs) var(--space-md);
      border: 1px solid rgba(255,255,255,0.4);
      border-radius: 999px;
      font-size: 0.85rem;
      font-weight: 600;
      color: rgba(255,255,255,0.95);
      background: rgba(255,255,255,0.1);
    }

    /* Lectures grid */
    .lectures-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--space-lg);
      max-width: 1000px;
      margin: var(--space-xl) auto;
      padding: 0 var(--space-lg);
    }

    /* Lecture card */
    .lecture-card {
      display: flex;
      gap: var(--space-lg);
      background: var(--color-surface);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-sm);
      padding: var(--space-lg);
      border: 1px solid var(--color-border);
      border-left: 5px solid var(--color-primary);
      transition: transform 0.25s ease, box-shadow 0.25s ease;
    }

    .lecture-card:hover {
      transform: translateY(-3px);
      box-shadow: var(--shadow-md);
    }

    /* Color cycling for left border */
    .lecture-card:nth-child(7n+1) { border-left-color: var(--color-primary); }
    .lecture-card:nth-child(7n+2) { border-left-color: var(--color-secondary); }
    .lecture-card:nth-child(7n+3) { border-left-color: var(--color-accent); }
    .lecture-card:nth-child(7n+4) { border-left-color: #5c6bc0; }
    .lecture-card:nth-child(7n+5) { border-left-color: #26a69a; }
    .lecture-card:nth-child(7n+6) { border-left-color: #ef6c00; }
    .lecture-card:nth-child(7n+7) { border-left-color: #1565c0; }

    /* Lecture number */
    .lecture-number {
      flex-shrink: 0;
      width: 56px;
      height: 56px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--color-primary);
      background: var(--color-math-bg);
      border-radius: 50%;
    }

    /* Lecture content area */
    .lecture-content {
      flex: 1;
      min-width: 0;
    }

    .lecture-title {
      font-size: 1.2rem;
      font-weight: 700;
      color: var(--color-primary);
      margin-bottom: var(--space-sm);
      line-height: 1.3;
    }

    .lecture-meta {
      display: flex;
      gap: var(--space-sm);
      margin-bottom: var(--space-md);
    }

    .lecture-meta span {
      padding: var(--space-xs) var(--space-sm);
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .lecture-duration {
      background: #e8eaf6;
      color: var(--color-primary);
    }

    .lecture-level {
      background: #e0f2f1;
      color: var(--color-secondary);
    }

    .lecture-abstract {
      font-size: 0.95rem;
      line-height: 1.7;
      color: var(--color-text);
      margin-bottom: var(--space-md);
    }

    .lecture-topics h4 {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--color-secondary);
      margin-bottom: var(--space-sm);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .lecture-topics ul {
      list-style: disc;
      padding-left: 1.25em;
    }

    .lecture-topics li {
      font-size: 0.85rem;
      color: var(--color-text-light);
      line-height: 1.5;
      margin-bottom: var(--space-xs);
    }

    /* Responsive: on small screens, stack number above content */
    @media (max-width: 600px) {
      .lecture-card {
        flex-direction: column;
        align-items: flex-start;
      }
    }

    /* Two-column grid on large screens */
    @media (min-width: 1200px) {
      .lectures-grid {
        grid-template-columns: repeat(2, 1fr);
        max-width: 1200px;
      }
    }
  </style>
</head>
<body>
  <nav id="navbar">
    <a href="index.html" class="nav-brand">Math for AI</a>
    <button class="nav-toggle" aria-label="Toggle navigation" aria-expanded="false">
      <span></span>
      <span></span>
      <span></span>
    </button>
    <div class="nav-links">
      <a href="index.html">Home</a>
      <a href="index.html#math-concepts">Math</a>
      <a href="index.html#visualizations">Visualizations</a>
      <a href="#lectures">Lectures</a>
    </div>
  </nav>

  <header class="plan-hero">
    <h1>Lecture Proposals</h1>
    <p class="subtitle">Thirty-nine lectures at the intersection of mathematics, AI, and finance &mdash; designed for the UAE&rsquo;s top young mathematicians</p>
    <span class="version-badge">UAE Math Talent Program 2026</span>
  </header>

  <section id="lectures" class="lecture-proposals">
    <div class="lectures-grid">

      <!-- ==================== LECTURE 1 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">1</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;The Geometry of Money: How Curved Spaces Hide Inside Your Bank&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Advanced</span>
          </div>
          <p class="lecture-abstract">Every time you open a banking app, invisible geometry is at work. Not the flat Euclidean kind from textbooks &mdash; we mean the curved, high-dimensional kind that makes GPS satellites correct for relativity and helps Netflix guess your next binge.<br><br>In this lecture, we start from a question that sounds simple: &ldquo;How similar are two bank customers?&rdquo; The Euclidean answer &mdash; straight-line distance &mdash; fails spectacularly when your data lives in 200 dimensions. We will build, from first principles, the mathematical machinery that modern AI actually uses: cosine similarity on the unit hypersphere, Mahalanobis distance that respects correlations, and the surprising connection between portfolio optimization and Riemannian manifolds.<br><br>You will see why the covariance matrix is secretly a metric tensor, why eigenvalues tell you which financial risks are real and which are noise, and how gradient descent on curved surfaces is fundamentally different from the flat version. We will derive the key results ourselves &mdash; no hand-waving.<br><br>By the end, you will understand why Renaissance Technologies and Abu Dhabi&rsquo;s sovereign wealth funds hire differential geometers, and you will have the mathematical vocabulary to read their research papers.</p>
          <div class="lecture-topics">
            <h4>Key Mathematics</h4>
            <ul>
              <li>Inner product spaces, cosine similarity, hypersphere geometry</li>
              <li>Covariance matrices as metric tensors</li>
              <li>Eigendecomposition and principal component analysis (PCA)</li>
              <li>Riemannian gradient descent vs. Euclidean gradient descent</li>
              <li>Mahalanobis distance and its derivation</li>
              <li>Connections to Markowitz portfolio theory</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 2 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">2</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;Beating the House: The Mathematics of Fair Pricing When the Future is Uncertain&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Advanced</span>
          </div>
          <p class="lecture-abstract">Here is a number that controls trillions of dollars: the price of an option. Not a stock &mdash; an <em>option on</em> a stock. The right to buy or sell at a fixed price in the future. How do you price something whose value depends on an event that has not happened yet?<br><br>In 1973, Black, Scholes, and Merton answered this question and changed the world. Their formula &mdash; which earned a Nobel Prize &mdash; rests on an idea so elegant it should be taught in every math class: you can construct a portfolio that perfectly replicates any uncertain payoff, and therefore the price must equal the cost of that replication. No arbitrage. Pure logic.<br><br>We will derive the Black-Scholes equation from scratch, starting with nothing more than the normal distribution (which you already know) and the concept of a random walk. Along the way, we will encounter Ito&rsquo;s lemma &mdash; calculus for random processes &mdash; and see why the drift of a stock does not matter for pricing (a deeply counterintuitive result). We will connect this to how Dubai&rsquo;s NASDAQ and Abu Dhabi Securities Exchange price derivatives today, and why Islamic finance structures like sukuk require entirely different mathematical frameworks.<br><br>You leave with: the ability to price a European call option by hand and the conceptual foundation to understand every quantitative finance interview question.</p>
          <div class="lecture-topics">
            <h4>Key Mathematics</h4>
            <ul>
              <li>Geometric Brownian motion as a modeling assumption (stated without proof; rigorous treatment in Lecture 7)</li>
              <li>Ito&rsquo;s lemma (stochastic calculus core idea)</li>
              <li>The Black-Scholes PDE: derivation via replicating portfolio</li>
              <li>Risk-neutral pricing and why drift cancels</li>
              <li>The Black-Scholes formula and the role of the normal CDF</li>
              <li>Connection to heat equation (physics crossover)</li>
              <li>Islamic finance constraints: profit-sharing vs. interest-bearing instruments</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 3 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">3</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;The Bayesian Detective: How AI Catches Criminals, Fraudsters, and Liars in Real Time&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Advanced</span>
          </div>
          <p class="lecture-abstract">A transaction hits a Dubai bank&rsquo;s server. The AI has 50 milliseconds to decide: legitimate or fraud? The answer uses mathematics that a Presbyterian minister invented in 1763 to prove the existence of God.<br><br>Bayes&rsquo; theorem is the most powerful single equation in applied mathematics. In this lecture, we will go far beyond the textbook version. We start with the theorem itself and its proof (short and beautiful), then build upward through three levels of sophistication that real fraud detection systems use.<br><br>Level 1: Naive Bayes classifiers &mdash; why assuming independence is wrong but works anyway (and the precise conditions under which it fails). Level 2: Bayesian networks &mdash; directed acyclic graphs where conditional probabilities propagate through chains of evidence. You will construct one for transaction fraud and compute posterior probabilities by hand. Level 3: Markov Chain Monte Carlo &mdash; when exact Bayesian inference is computationally impossible, we sample instead. We will derive the Metropolis-Hastings algorithm and prove it converges to the correct posterior.<br><br>Real numbers: UAE banks process over 2 billion card transactions per year. At a 0.1% fraud rate, even 99.9% accuracy means tens of thousands of false alarms. We will quantify this tradeoff using ROC curves and signal detection theory.</p>
          <div class="lecture-topics">
            <h4>Key Mathematics</h4>
            <ul>
              <li>Bayes&rsquo; theorem: derivation, prior/posterior/likelihood</li>
              <li>Naive Bayes classifiers and the independence assumption</li>
              <li>Bayesian networks and belief propagation on DAGs</li>
              <li>Markov Chain Monte Carlo: Metropolis-Hastings derivation</li>
              <li>Convergence proof sketch (detailed balance condition)</li>
              <li>ROC curves, AUC, precision-recall tradeoffs</li>
              <li>Signal detection theory and decision boundaries</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 4 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">4</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;Gradient Descent and the Loss Landscape: A Hiker&rsquo;s Guide to Training Neural Networks&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Advanced</span>
          </div>
          <p class="lecture-abstract">Training a neural network is, at its core, an optimization problem. You have millions of parameters, a loss function that measures how wrong your network is, and one job: find the parameter values that make the loss as small as possible. Simple? The loss landscape of a modern network has more dimensions than there are atoms in the observable universe.<br><br>In this lecture, we will hike through that landscape together. We begin with vanilla gradient descent &mdash; computing partial derivatives by hand for a two-layer network, using nothing beyond the chain rule. Then we face the real problems: saddle points (far more common than local minima in high dimensions &mdash; we will prove why), vanishing and exploding gradients (a concrete eigenvalue argument), and the computational impossibility of full-batch gradient descent on large datasets.<br><br>Each problem demands a mathematical solution. Stochastic gradient descent introduces controlled randomness. Momentum adds a velocity term from physics. Adam combines moving averages of gradients and squared gradients &mdash; we will derive it and show why the bias correction term exists. For the mathematically ambitious: we will sketch why SGD implicitly regularizes toward flat minima, connecting optimization to generalization through the lens of information theory.<br><br>We will apply every concept to a financial example: training a network to predict credit default on a real (anonymized) UAE lending dataset.</p>
          <div class="lecture-topics">
            <h4>Key Mathematics</h4>
            <ul>
              <li>Multivariable chain rule and backpropagation derivation</li>
              <li>Gradient computation for a concrete two-layer network</li>
              <li>Saddle points in high dimensions: why Hessian eigenvalue distribution matters</li>
              <li>Stochastic gradient descent: convergence rate analysis</li>
              <li>Momentum, RMSProp, Adam: derivation and bias correction</li>
              <li>Vanishing/exploding gradients: eigenvalue argument</li>
              <li>Implicit regularization and flat vs. sharp minima (overview)</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 5 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">5</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;Cryptography Meets Finance: The Number Theory Behind Digital Money&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Advanced</span>
          </div>
          <p class="lecture-abstract">Every digital dirham, every Bitcoin, every bank transfer you have ever made rests on a single mathematical belief: that multiplying two large primes is easy, but factoring their product is hard. If someone proves this wrong tomorrow, the global financial system collapses overnight.<br><br>This lecture is about the number theory that makes digital finance possible &mdash; and the quantum computing threat that might break it. We begin with modular arithmetic and build up to RSA encryption: you will generate your own public-private key pair and encrypt a message by hand. We will prove why RSA works (Euler&rsquo;s theorem), estimate why it is hard to break (the prime number theorem and the difficulty of factoring), and see how every contactless payment in the UAE uses elliptic curve cryptography &mdash; a beautiful intersection of algebraic geometry and number theory.<br><br>Then we go deeper. Blockchain consensus mechanisms use hash functions as mathematical commitments. We will formalize what &ldquo;collision resistance&rdquo; means and why proof-of-stake (which the UAE&rsquo;s digital dirham exploration favors) requires different mathematical guarantees than proof-of-work. For the finale: Shor&rsquo;s algorithm &mdash; the quantum algorithm that factors integers in polynomial time. We will sketch its mathematical core (the quantum Fourier transform) and discuss what post-quantum cryptography looks like.</p>
          <div class="lecture-topics">
            <h4>Key Mathematics</h4>
            <ul>
              <li>Modular arithmetic, Euler&rsquo;s totient function, Fermat&rsquo;s little theorem</li>
              <li>RSA: key generation, encryption, decryption, correctness proof</li>
              <li>Prime number theorem and factoring complexity</li>
              <li>Elliptic curves over finite fields: group law and ECDSA</li>
              <li>Hash functions: collision resistance, preimage resistance</li>
              <li>Blockchain: Merkle trees, consensus mechanism mathematics</li>
              <li>Shor&rsquo;s algorithm: quantum Fourier transform (conceptual sketch)</li>
              <li>Post-quantum lattice-based cryptography (overview)</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 6 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">6</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;When AI Decides Your Future: The Mathematics of Fairness, Bias, and Justice&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Advanced</span>
          </div>
          <p class="lecture-abstract">An AI model denies a loan application. The applicant asks: &ldquo;Why?&rdquo; The bank says: &ldquo;The algorithm decided.&rdquo; Is that acceptable? More importantly &mdash; can mathematics itself tell us whether the decision was <em>fair</em>?<br><br>This lecture confronts one of the most important theorems in modern AI, and one of the most disturbing: it is mathematically <em>impossible</em> to satisfy all reasonable definitions of fairness simultaneously. We will prove this impossibility result rigorously. You will see that &ldquo;treat everyone equally&rdquo; (demographic parity), &ldquo;be equally accurate for all groups&rdquo; (equalized odds), and &ldquo;a positive prediction should mean the same thing for everyone&rdquo; (calibration) cannot all hold at once, except in trivial cases.<br><br>This is not philosophy &mdash; this is combinatorics and probability theory with real consequences. We will formalize each fairness criterion as a precise mathematical constraint, construct the proof by contradiction, and examine what tradeoffs real systems must make. We will analyze a credit scoring model and compute its fairness metrics across different demographic groups, using real statistical methods: conditional probability, Simpson&rsquo;s paradox (which we will derive), and causal inference via do-calculus.<br><br>In the UAE, where AI is being deployed in government services, banking, and healthcare at unprecedented scale, these mathematical constraints are not abstract. They determine who gets loans, jobs, and opportunities. You will leave understanding that fairness in AI is a mathematical design choice, not a default &mdash; and that mathematicians are the ones who must make it.</p>
          <div class="lecture-topics">
            <h4>Key Mathematics</h4>
            <ul>
              <li>Formal definitions: demographic parity, equalized odds, calibration</li>
              <li>Impossibility theorem: proof that these cannot simultaneously hold</li>
              <li>Simpson&rsquo;s paradox: construction and proof</li>
              <li>Conditional probability and conditional independence</li>
              <li>Causal inference basics: do-calculus notation</li>
              <li>Confusion matrix algebra: TPR, FPR, PPV relationships</li>
              <li>Constrained optimization: fairness as optimization constraints</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 7 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">7</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;From Random Walks to Wall Street: The Stochastic Processes That Model Markets&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Advanced</span>
          </div>
          <p class="lecture-abstract">In 1900, five years before Einstein published his paper on Brownian motion, a French PhD student named Louis Bachelier used the exact same mathematics to model stock prices. His thesis was ignored for sixty years. Today, his random walk model is the foundation of a $500 trillion derivatives market.<br><br>This lecture traces that mathematical journey. We start where Bachelier did: a symmetric random walk on the integers. We prove the key properties &mdash; expected value, variance growth, the arcsine law for last returns (one of the most counterintuitive results in probability). Then we take the continuum limit and arrive at Brownian motion, making rigorous the passage from discrete to continuous.<br><br>From Brownian motion, we build the tools that quantitative finance actually uses. The Ornstein-Uhlenbeck process models mean-reverting interest rates &mdash; critical for pricing sukuk and other Islamic fixed-income instruments. Geometric Brownian motion models stock prices (we will show why the logarithm matters). Poisson jump processes capture market crashes &mdash; rare events that Brownian motion misses entirely.<br><br>For the finale: we simulate a mini-portfolio of UAE stocks (Emaar, ADNOC, FAB) using each model, compare against real historical data, and see where the mathematics succeeds and where it fails. You will walk out able to spot when a financial model is lying to you &mdash; a skill worth more than any formula.</p>
          <div class="lecture-topics">
            <h4>Key Mathematics</h4>
            <ul>
              <li>Symmetric random walk: expectation, variance, arcsine law</li>
              <li>Central limit theorem and the continuum limit to Brownian motion</li>
              <li>Brownian motion properties: continuity, non-differentiability, quadratic variation</li>
              <li>Geometric Brownian motion: rigorous construction as exp(Wiener process with drift), log-normal distribution (this is the full derivation that Lecture 2 only assumed)</li>
              <li>Ornstein-Uhlenbeck process: mean reversion and its SDE</li>
              <li>Poisson jump-diffusion processes for crash modeling</li>
              <li>Monte Carlo simulation: convergence and variance reduction</li>
              <li>Model validation against real market data</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 8 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">8</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;The Attention Equation: How Transformers Learned to Read, Write, and Price&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Advanced</span>
          </div>
          <p class="lecture-abstract">In 2017, a paper titled &ldquo;Attention Is All You Need&rdquo; introduced eight equations that would reshape civilization. Today, every time ChatGPT writes a paragraph, every time Bloomberg Terminal summarizes earnings, every time a UAE bank&rsquo;s chatbot answers a customer query &mdash; those eight equations are running underneath. This lecture tears them apart, mathematically.<br><br>We begin with the core operation: scaled dot-product attention. You will derive it from first principles as a soft dictionary lookup &mdash; keys, queries, and values are just learned linear projections, and the softmax function turns inner products into a probability distribution over context. We will compute attention weights by hand for a toy sequence and see <em>why</em> $\frac{1}{\sqrt{d_k}}$ scaling prevents gradient saturation (a clean eigenvalue argument). Then multi-head attention: we prove it is equivalent to learning in multiple representation subspaces simultaneously, and show the dimensionality arithmetic that makes it work without increasing parameters.<br><br>From there, we build upward. Positional encoding &mdash; why sinusoidal functions form a basis that lets the model learn relative position. Layer normalization &mdash; why it stabilizes training (a variance argument). The residual stream &mdash; why skip connections create a sum over computational paths. Finally, we confront the deepest mathematical mystery of modern AI: scaling laws. We will examine Chinchilla&rsquo;s empirical power-law relationship between parameters, data, and loss &mdash; $L(N,D) \approx \left(\frac{N_c}{N}\right)^{\alpha_N} + \left(\frac{D_c}{D}\right)^{\alpha_D}$ &mdash; and discuss what, if anything, explains why it holds.<br><br>We close by connecting transformers to finance: how ADGM-regulated firms use fine-tuned language models for regulatory document parsing, and why the UAE&rsquo;s Falcon family of LLMs (built by TII in Abu Dhabi) represents a sovereign AI capability with mathematical infrastructure you now understand.</p>
          <div class="lecture-topics">
            <h4>Key Mathematics</h4>
            <ul>
              <li>Scaled dot-product attention: derivation as soft dictionary lookup</li>
              <li>Softmax function, temperature scaling, gradient saturation analysis</li>
              <li>Multi-head attention: subspace decomposition and parameter efficiency proof</li>
              <li>Positional encoding: Fourier basis representation and relative position</li>
              <li>Layer normalization: variance stabilization argument</li>
              <li>Residual connections as sum over computational paths</li>
              <li>Scaling laws: Chinchilla power-law fits, compute-optimal training</li>
              <li>Tokenization: byte-pair encoding as compression, vocabulary entropy</li>
              <li>Connection to kernel methods: attention as kernel regression</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 9 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">9</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;Noise Into Gold: How Diffusion Models Generate Financial Futures&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Advanced</span>
          </div>
          <p class="lecture-abstract">Here is an idea that sounds like alchemy: start with pure random noise &mdash; Gaussian static &mdash; and systematically remove it, step by step, until a photorealistic image emerges. This is how DALL-E, Stable Diffusion, and Midjourney work. The mathematics behind it is a stochastic differential equation running <em>backward in time</em>. And in 2024&ndash;2025, financial engineers realized this same mathematics can generate thousands of realistic market scenarios for stress-testing portfolios.<br><br>We start where all diffusion models start: the forward process. Add Gaussian noise incrementally to your data until it becomes pure noise. This is an Ornstein-Uhlenbeck-like SDE (you met the OU process in Lecture 7 &mdash; now we run it in the opposite direction). The deep insight is that to reverse this process, you need the <em>score function</em> &mdash; the gradient of the log-probability density, $\nabla_x \log p_t(x)$. We will derive Anderson&rsquo;s reverse-time SDE and prove that knowledge of the score at every noise level is sufficient to generate perfect samples.<br><br>How do you learn the score? Score matching &mdash; a beautiful trick where you train a neural network to predict the noise that was added, and this turns out to be mathematically equivalent to learning $\nabla_x \log p_t(x)$. We will prove this equivalence rigorously (it is a two-line derivation using integration by parts and the chain rule &mdash; elegant enough for any mathematician).<br><br>Then we turn to finance. A Diffusion Factor Model (DFM) decomposes the score function into a <em>subspace score</em> capturing systemic risk from common market factors and a <em>complementary score</em> handling idiosyncratic noise. We will see how this generates correlated multi-asset return scenarios that respect the fat tails and regime switches that Gaussian copulas infamously missed in 2008. Dubai&rsquo;s DIFC Innovation Hub is funding startups applying exactly these techniques to Islamic finance portfolio stress-testing.</p>
          <div class="lecture-topics">
            <h4>Key Mathematics</h4>
            <ul>
              <li>Forward diffusion as SDE: variance schedule, noise process</li>
              <li>Reverse-time SDE (Anderson 1982): derivation and existence conditions</li>
              <li>Score function: $\nabla_x \log p_t(x)$ and its geometric interpretation</li>
              <li>Score matching: denoising score matching equivalence proof</li>
              <li>Langevin dynamics: sampling via score function + noise</li>
              <li>Diffusion Factor Models: subspace score decomposition for systemic vs. idiosyncratic risk</li>
              <li>Connection to Fokker-Planck equation: probability flow ODE</li>
              <li>Fat tails and regime switching: where Gaussian assumptions fail</li>
              <li>ELBO and variational bounds for diffusion models</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 10 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">10</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;Quantum Finance: When Superposition Meets the Stock Market&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Advanced</span>
          </div>
          <p class="lecture-abstract">In Lecture 5, you met Shor&rsquo;s algorithm &mdash; the quantum threat to cryptography. Now we explore the constructive side: quantum algorithms that solve financial problems <em>faster than any classical computer can</em>. This is not science fiction. In 2025, Abu Dhabi&rsquo;s Technology Innovation Institute partnered with Quantinuum to access the world&rsquo;s highest-fidelity quantum processors, and their first target applications include financial optimization and risk simulation.<br><br>We begin with the mathematical framework of quantum computing itself. A qubit is a vector in $\mathbb{C}^2$. Two qubits live in $\mathbb{C}^2 \otimes \mathbb{C}^2 = \mathbb{C}^4$. Entanglement is a state that cannot be written as a tensor product &mdash; we will prove this for the Bell state using a rank argument on the coefficient matrix. Quantum gates are unitary matrices; measurement collapses superposition according to Born&rsquo;s rule (probability = squared modulus of amplitude). This is all linear algebra &mdash; the same linear algebra you already know, but over the complex numbers.<br><br>With this toolkit, we build three financial quantum algorithms. First: the Quantum Approximate Optimization Algorithm (QAOA) for portfolio optimization. Classical portfolio selection is NP-hard when you add integer constraints (you cannot buy 0.37 of a stock). QAOA maps this to finding the ground state of an Ising Hamiltonian &mdash; we will construct the cost Hamiltonian and the mixing Hamiltonian, and prove why alternating them explores the solution space. Second: Variational Quantum Eigensolver (VQE) for pricing complex derivatives &mdash; a hybrid classical-quantum loop where the quantum circuit evaluates a parameterized state and classical optimization updates the parameters. Third: quantum amplitude estimation for Monte Carlo acceleration &mdash; a quadratic speedup ($O(\sqrt{N})$ vs. $O(N)$) for computing expected values like Value-at-Risk.<br><br>We close with an honest assessment: what quantum advantage actually means in 2026, why current NISQ (noisy intermediate-scale quantum) devices require error mitigation, and why the UAE&rsquo;s investment in quantum infrastructure positions it at the frontier of computational finance.</p>
          <div class="lecture-topics">
            <h4>Key Mathematics</h4>
            <ul>
              <li>Qubit formalism: $\mathbb{C}^2$, Bloch sphere, measurement postulates</li>
              <li>Tensor products and entanglement: Bell states, Schmidt decomposition</li>
              <li>Unitary evolution: quantum gates as $SU(2^n)$ matrices</li>
              <li>QAOA: Ising Hamiltonian formulation, cost and mixing operators, variational principle</li>
              <li>Portfolio optimization as quadratic unconstrained binary optimization (QUBO)</li>
              <li>VQE: parameterized quantum circuits, classical-quantum optimization loop</li>
              <li>Quantum amplitude estimation: quadratic speedup proof sketch</li>
              <li>NISQ error mitigation: zero-noise extrapolation, probabilistic error cancellation</li>
              <li>Comparison: quantum vs. classical complexity for financial problems</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 11 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">11</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;The Trading Agent: Reinforcement Learning and the Mathematics of Sequential Decisions&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Advanced</span>
          </div>
          <p class="lecture-abstract">A trading algorithm wakes up every morning with one question: given everything I know about the market right now, what should I do? Buy, sell, hold &mdash; and in what quantities? This is not a prediction problem (Lectures 3 and 4 handle prediction). This is a <em>decision</em> problem, where today&rsquo;s choice affects tomorrow&rsquo;s options. The mathematical framework for optimal sequential decisions under uncertainty is reinforcement learning, and its application to finance is exploding.<br><br>We begin with Markov Decision Processes &mdash; the formal language. A state (your current portfolio plus market conditions), an action space (all possible trades), a transition function (how the market evolves), and a reward (your risk-adjusted return). The Bellman equation emerges naturally: the value of being in state $s$ equals the immediate reward plus the discounted value of the best next state. We will derive it, prove it has a unique fixed point (Banach contraction theorem &mdash; one of the most beautiful proofs in analysis), and see why solving it exactly is computationally impossible for realistic state spaces.<br><br>This impossibility drives us to <em>approximate</em> methods. Deep Q-Networks (DQN) use neural networks to approximate the Bellman fixed point &mdash; we will derive the loss function and see why &ldquo;experience replay&rdquo; (training on shuffled past transitions) breaks temporal correlations that would otherwise destabilize learning. Policy gradient methods (REINFORCE, PPO) take a different approach: parameterize the policy directly and differentiate expected reward with respect to policy parameters. The policy gradient theorem is remarkable &mdash; we will prove it and see how it circumvents the need to model transitions at all.<br><br>For the financial application: we train a portfolio optimization agent on UAE market data (Emaar, ADNOC, FAB, du). The Sharpe ratio becomes the reward signal, but naively maximizing it causes catastrophic risk-taking. We will derive risk-adjusted reward functions that incorporate drawdown penalties and CVaR constraints, connecting reinforcement learning to the risk measures that DFSA and SCA regulators actually require.</p>
          <div class="lecture-topics">
            <h4>Key Mathematics</h4>
            <ul>
              <li>Markov Decision Processes: states, actions, transitions, rewards</li>
              <li>Bellman equation: derivation and uniqueness via Banach fixed-point theorem</li>
              <li>Value iteration and policy iteration: convergence proofs</li>
              <li>Deep Q-Networks: function approximation, target networks, experience replay</li>
              <li>Policy gradient theorem: derivation via log-derivative trick</li>
              <li>REINFORCE, Actor-Critic, Proximal Policy Optimization (PPO)</li>
              <li>Sharpe ratio as reward signal: differentiability and optimization challenges</li>
              <li>Risk constraints in RL: CVaR-constrained MDPs</li>
              <li>Exploration vs. exploitation: epsilon-greedy, UCB, entropy regularization</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 12 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">12</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;The Hidden Network: Graph Neural Networks and the Topology of Financial Contagion&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Advanced</span>
          </div>
          <p class="lecture-abstract">When Lehman Brothers collapsed in 2008, it did not just fail &mdash; it <em>infected</em> the entire global financial system through a web of counterparty obligations that nobody fully understood. The mathematics of that contagion is graph theory, and the AI that now monitors these networks in real time uses Graph Neural Networks &mdash; the frontier where topology meets deep learning.<br><br>We begin with the mathematics of financial networks. Banks, funds, and corporations form nodes; loans, derivatives contracts, and payment flows form edges. The adjacency matrix $A$ encodes this structure, and its spectral properties reveal everything: the largest eigenvalue of $A$ determines epidemic thresholds for default cascading &mdash; we will derive this result using the spectral radius and Perron-Frobenius theory. The graph Laplacian $L = D - A$ (where $D$ is the degree matrix) governs diffusion on graphs; its second-smallest eigenvalue, the Fiedler value, measures how &ldquo;connected&rdquo; the financial system is &mdash; and therefore how vulnerable to contagion.<br><br>With this spectral foundation, we build Graph Neural Networks. The key operation is <em>message passing</em>: each node aggregates information from its neighbors, transforms it, and updates its own representation. We will derive the message-passing framework mathematically and show that it is equivalent to a learned polynomial filter on the graph Laplacian&rsquo;s eigenvalues &mdash; this is <em>spectral graph convolution</em>, and it directly extends the convolution theorem you know from Fourier analysis to arbitrary graph topologies.<br><br>For application: we construct a GNN that predicts systemic risk in a network of UAE financial institutions (ADCB, Mashreq, Emirates NBD, FAB, ADIA) modeled from public interbank data. The GNN learns <em>permutation-equivariant</em> representations &mdash; we will prove why this symmetry property is essential (a financial risk measure should not depend on how you label the banks). Recent research shows GNNs achieve 94% improvement over traditional ML methods for network-level risk prediction, precisely because they exploit the topological structure that tabular models ignore.<br><br>The Central Bank of the UAE is building exactly these monitoring systems. You will leave understanding both the mathematics and why graph-aware AI is the future of financial regulation.</p>
          <div class="lecture-topics">
            <h4>Key Mathematics</h4>
            <ul>
              <li>Graph theory: adjacency matrix, degree matrix, graph Laplacian</li>
              <li>Spectral graph theory: eigenvalues of $L$, Fiedler value, algebraic connectivity</li>
              <li>Perron-Frobenius theorem and epidemic threshold for default cascading</li>
              <li>Message-passing neural networks: aggregation, update, readout functions</li>
              <li>Spectral graph convolution: polynomial filters on Laplacian eigenvalues</li>
              <li>Graph Fourier transform: extending convolution theorem to irregular domains</li>
              <li>Permutation equivariance: proof of GNN symmetry property</li>
              <li>Graph attention networks: learned edge weights via attention</li>
              <li>Systemic risk measures: DebtRank, contagion simulation on networks</li>
              <li>Connection to random graph theory: Erdos-Renyi thresholds for network resilience</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 13 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">13</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;Mathematics in the Age of AI: Why the Best is Yet to Come&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Keynote</span>
          </div>
          <p class="lecture-abstract">In August 2025, something happened that would have been unthinkable a decade ago: an AI system called AlphaProof solved problems from the International Mathematical Olympiad at a silver-medal level. Headlines screamed that mathematics was over. They were spectacularly wrong.<br><br>This lecture is a love letter to the future of mathematics &mdash; and a roadmap for your place in it.<br><br>We will start with the honest question: what can AI actually do in mathematics today? We will look at what AlphaProof did (and, crucially, what it could not do). We will examine how large language models generate plausible-sounding proofs that are subtly, devastatingly wrong &mdash; and why detecting the error requires exactly the kind of structured reasoning you are training right now. We will see how AI tools like Lean 4 and Coq are not replacing mathematicians but amplifying them &mdash; the way the telescope amplified astronomers. The mathematicians who thrive in 2035 will not be those who compute fastest (AI already wins that race). They will be those who ask the deepest questions, who see connections across fields, who have the taste to distinguish an interesting conjecture from a trivial one.<br><br>Then we turn to you. The UAE is investing billions in AI infrastructure &mdash; from TII&rsquo;s Falcon foundation models to the 10-square-mile AI campus in Abu Dhabi. Every one of these systems needs mathematicians: people who understand convergence, stability, generalization, and the difference between a proof and a heuristic. The world is not producing enough of you. The demand for mathematical minds that can work alongside AI &mdash; guiding it, correcting it, asking it the right questions &mdash; has never been higher.<br><br>We will close with stories of mathematicians your age who are already using AI-assisted proof to make genuine discoveries. Not in twenty years. Now. The age of AI is not the end of mathematics. It is the beginning of the most exciting era mathematics has ever known.</p>
          <div class="lecture-topics">
            <h4>Key Themes</h4>
            <ul>
              <li>What AI can and cannot do in mathematics today (AlphaProof, Lean 4, limitations)</li>
              <li>Why mathematical taste, intuition, and question-asking cannot be automated</li>
              <li>The &ldquo;telescope analogy&rdquo;: AI as amplifier, not replacement</li>
              <li>Career landscape: why demand for mathematicians is accelerating, not declining</li>
              <li>UAE&rsquo;s AI infrastructure and where mathematicians fit in</li>
              <li>Stories of young mathematicians making discoveries with AI tools</li>
              <li>The difference between computation and understanding</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 14 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">14</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;The Unreasonable Effectiveness of Mathematics: Why the Universe Speaks Algebra&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Keynote</span>
          </div>
          <p class="lecture-abstract">In 1960, the physicist Eugene Wigner wrote an essay with a title that has haunted scientists ever since: &ldquo;The Unreasonable Effectiveness of Mathematics in the Natural Sciences.&rdquo; His question was simple and profound: why does mathematics &mdash; something invented by human minds playing with abstract symbols &mdash; describe the physical universe so perfectly? Why did Maxwell&rsquo;s equations, written on a single page, predict radio waves decades before anyone built a radio? Why did Dirac&rsquo;s equation, a piece of pure algebra, predict the existence of antimatter before any experiment found it?<br><br>This lecture explores the deepest question at the intersection of mathematics and reality &mdash; and we will discover that the mystery has only deepened in the age of AI.<br><br>We will trace four astonishing stories. First: how a 19th-century mathematician named Bernhard Riemann invented a geometry of curved spaces purely for intellectual pleasure, and how Einstein used exactly that geometry sixty years later to describe gravity. No one asked Riemann to be useful. He simply followed the mathematics, and the universe was waiting. Second: how the same matrix algebra used in quantum mechanics turned out to be the exact formalism needed for Google&rsquo;s PageRank algorithm and for the attention mechanism in ChatGPT. Third: how number theory &mdash; the &ldquo;purest&rdquo; branch of mathematics, studied for millennia with zero practical applications &mdash; suddenly became the foundation of all internet security when RSA encryption was invented. Fourth: how group theory, invented to study the symmetries of polynomial roots, now governs everything from particle physics to crystallography to error-correcting codes in your phone.<br><br>The pattern is unmistakable and unexplained: mathematics developed for its own beauty keeps turning out to be exactly what the universe, and now what AI, requires. We will ask why. Is mathematics discovered or invented? Is the universe fundamentally mathematical? These are not idle philosophical musings &mdash; they are questions that determine how you should think about your own education. Because if the pattern holds, then the &ldquo;useless&rdquo; pure mathematics you study today is the applied mathematics of tomorrow.</p>
          <div class="lecture-topics">
            <h4>Key Themes</h4>
            <ul>
              <li>Wigner&rsquo;s essay and the central mystery: why does abstract math describe reality?</li>
              <li>Riemann geometry to general relativity: beauty first, application later</li>
              <li>Matrix algebra: from quantum mechanics to PageRank to transformers</li>
              <li>Number theory to cryptography: pure to applied in one generation</li>
              <li>Group theory: polynomial roots to particle physics to error-correcting codes</li>
              <li>Is mathematics discovered or invented? The Platonism debate</li>
              <li>Why studying &ldquo;useless&rdquo; pure math is the most practical thing you can do</li>
              <li>Historical examples of mathematicians who followed curiosity and changed the world</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 15 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">15</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;Proof, Truth, and the Limits of Knowledge: What Mathematics Cannot Know&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Keynote</span>
          </div>
          <p class="lecture-abstract">Mathematics is the one discipline where you can know something with absolute certainty. A proven theorem is true forever &mdash; no experiment can overturn it, no new data can invalidate it. Pythagoras was right in 500 BC and he is still right today. This makes mathematics unique among all human endeavors.<br><br>And then, in 1931, a quiet 25-year-old Austrian named Kurt G&ouml;del destroyed this paradise.<br><br>G&ouml;del proved &mdash; with mathematical certainty &mdash; that mathematics itself has limits. Any consistent mathematical system powerful enough to describe basic arithmetic must contain true statements that can never be proven within that system. Not &ldquo;have not been proven yet.&rdquo; Cannot be proven. Ever. By anyone. This is G&ouml;del&rsquo;s First Incompleteness Theorem, and it is one of the most stunning intellectual achievements in human history.<br><br>We will build the proof idea from scratch, using no prerequisites beyond logic and natural numbers. The core trick &mdash; G&ouml;del numbering, which encodes mathematical statements as numbers so that mathematics can talk about itself &mdash; is a stroke of genius you will never forget once you see it. We will then connect this to Alan Turing&rsquo;s 1936 proof that there exist problems no computer can ever solve (the Halting Problem), and to Gregory Chaitin&rsquo;s discovery of &Omega; &mdash; a specific real number that is perfectly well-defined but whose digits can never be computed.<br><br>But this lecture is not about despair. It is about intellectual courage. G&ouml;del, Turing, and Chaitin did not make mathematics weaker. They made it deeper. They showed that the landscape of mathematical truth is infinitely richer than any single formal system can capture. For AI, this has profound implications: every AI system is a formal system, and therefore every AI system has G&ouml;delian blind spots &mdash; truths it cannot discover. This is not a bug. It is a theorem.<br><br>You will leave this lecture understanding that the limits of knowledge are themselves a form of knowledge &mdash; and that pushing against those limits is what makes mathematics the most honest, the most humble, and the most audacious discipline that humans have ever created.</p>
          <div class="lecture-topics">
            <h4>Key Themes</h4>
            <ul>
              <li>Why mathematical proof is unique: certainty that no other field can claim</li>
              <li>G&ouml;del&rsquo;s First Incompleteness Theorem: the statement, the proof idea, the shock</li>
              <li>G&ouml;del numbering: mathematics talking about itself</li>
              <li>Turing&rsquo;s Halting Problem: undecidable problems and the limits of computation</li>
              <li>Chaitin&rsquo;s &Omega;: a knowable number whose digits are unknowable</li>
              <li>Implications for AI: every formal system has G&ouml;delian blind spots</li>
              <li>The philosophy: limits of knowledge as knowledge itself</li>
              <li>Why this makes mathematics more exciting, not less</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 16 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">16</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;The Billion-Dollar Equations: Five Formulas That Bent the Arc of History&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Keynote</span>
          </div>
          <p class="lecture-abstract">Behind every revolution &mdash; industrial, digital, financial, scientific &mdash; there is usually a single equation. Not a textbook of equations. One. Written by one person, often in obscurity, often without any idea of what it would unleash.<br><br>This lecture tells five stories of equations that changed the world, and the human dramas behind them.<br><br><strong>Story One: Euler&rsquo;s Identity.</strong> In 1748, Leonhard Euler &mdash; the most prolific mathematician in history, who continued publishing after going blind &mdash; revealed that $e^{i\pi} + 1 = 0$. Five fundamental constants, three basic operations, one statement of impossible elegance. We will derive it using Taylor series and see why Richard Feynman called it &ldquo;the most remarkable formula in mathematics.&rdquo; More than beauty: this identity is the reason electrical engineering, quantum mechanics, and signal processing work. Every time your phone processes a voice call, Euler&rsquo;s formula is running.<br><br><strong>Story Two: Shannon&rsquo;s Entropy.</strong> In 1948, Claude Shannon, a 32-year-old engineer at Bell Labs, defined the fundamental limit of communication: $H = -\sum p_i \log p_i$. Before Shannon, &ldquo;information&rdquo; was a vague word. After Shannon, it was a precise mathematical quantity with units (bits). We will derive why this formula is the unique function satisfying three reasonable axioms. This equation is why you can stream 4K video on your phone. It is also the loss function (cross-entropy) used to train every large language model, including the ones generating AI text today.<br><br><strong>Story Three: Navier-Stokes.</strong> In the 1840s, Claude-Louis Navier and George Stokes wrote down the equations governing fluid flow. We still cannot prove whether their solutions always exist. The Clay Mathematics Institute offers one million dollars for a proof. We will state the problem precisely and see why it resists the best minds in mathematics &mdash; and why solving it would revolutionize weather prediction, aircraft design, and blood flow modeling.<br><br><strong>Story Four: Black-Scholes.</strong> You met this in Lecture 2. Here we tell the human story. Fischer Black was a physicist with no economics degree. Myron Scholes was told his PhD thesis was unpublishable. Their equation created the modern derivatives market &mdash; then, when Long-Term Capital Management used it without understanding its assumptions, nearly destroyed the global economy in 1998. The lesson: an equation is only as good as the wisdom of the person wielding it.<br><br><strong>Story Five: The Bellman Equation.</strong> Richard Bellman, working at the RAND Corporation during the Cold War, invented dynamic programming and named it deliberately to sound boring so the Pentagon would not cut his funding. His equation $V(s) = \max_a [R(s,a) + \gamma V(s')]$ is the mathematical backbone of every AI that learns from experience &mdash; from AlphaGo to autonomous vehicles to the trading agents in Lecture 11.<br><br>Each story follows the same arc: a person, an insight, an equation, and a world that never looked the same afterward. Mathematics is not a spectator sport. It is the engine of civilization. And the next equation on this list might be yours.</p>
          <div class="lecture-topics">
            <h4>Key Themes</h4>
            <ul>
              <li>Euler&rsquo;s identity: derivation, beauty, and engineering applications</li>
              <li>Shannon&rsquo;s entropy: the birth of information theory, connection to AI loss functions</li>
              <li>Navier-Stokes: a million-dollar unsolved problem, why existence proofs matter</li>
              <li>Black-Scholes: the human story, the trillion-dollar market, the catastrophic failure</li>
              <li>Bellman equation: Cold War origins, dynamic programming, foundation of modern RL</li>
              <li>The common pattern: one person, one equation, world-changing consequences</li>
              <li>Mathematics as the engine of civilization, not an academic exercise</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 17 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">17</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;The Last Great Problems: Unsolved Questions That Could Change Everything&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Keynote</span>
          </div>
          <p class="lecture-abstract">Right now, as you sit here, there exist mathematical problems so important that solving any one of them would make you immortal. Not famous. Immortal &mdash; your name alongside Euclid, Gauss, and Euler, spoken by mathematicians a thousand years from now.<br><br>Seven problems were designated as the Millennium Prize Problems in 2000 by the Clay Mathematics Institute. Each carries a one-million-dollar prize. Only one has been solved: the Poincar&eacute; Conjecture, by Grigori Perelman &mdash; a reclusive Russian mathematician who then refused the million dollars, refused the Fields Medal, and moved back in with his mother. We will tell his extraordinary story.<br><br>Then we will explore three of the remaining unsolved problems &mdash; not as distant curiosities, but as living challenges that intersect directly with the mathematics you already know.<br><br><strong>P vs NP.</strong> Every time you solve a puzzle, you exploit the fact that checking a solution is easy. Checking that a Sudoku is correct takes seconds. Finding the solution might take hours. Is this asymmetry fundamental, or could there be a shortcut we have not found? If P = NP, then every problem whose solution can be quickly checked can also be quickly solved. Cryptography collapses. Drug discovery becomes trivial. AI becomes omniscient. Most mathematicians believe P does not equal NP &mdash; but no one can prove it. We will formalize the question precisely and see why it is so resistant to attack.<br><br><strong>The Riemann Hypothesis.</strong> The distribution of prime numbers &mdash; those atoms of arithmetic &mdash; follows a mysterious pattern connected to the zeros of a function Riemann defined in 1859. If the hypothesis is true (and every computation ever performed suggests it is), then we understand primes with exquisite precision. If it is false, vast swaths of number theory collapse. We will see the zeta function, plot its zeros, and understand what the hypothesis actually claims.<br><br><strong>The Birch and Swinnerton-Dyer Conjecture.</strong> Elliptic curves &mdash; the same objects you met in Lecture 5 securing your bank transactions &mdash; hide a deep connection between their geometric shape and the behavior of a certain function at a single point. This conjecture links algebra, geometry, and analysis in a way no one fully understands.<br><br>We will close with an invitation. The people who will solve these problems are alive today. Some of them are your age. The history of mathematics is not a finished story. It is an ongoing adventure &mdash; and you are exactly the kind of mind it needs.</p>
          <div class="lecture-topics">
            <h4>Key Themes</h4>
            <ul>
              <li>The Millennium Prize Problems: what they are, why they matter</li>
              <li>Grigori Perelman and the Poincar&eacute; Conjecture: the human story of the only solution</li>
              <li>P vs NP: what it really asks, why it matters for cryptography and AI</li>
              <li>The Riemann Hypothesis: prime numbers, the zeta function, 167 years of mystery</li>
              <li>Birch and Swinnerton-Dyer: elliptic curves from Lecture 5 at the frontier of research</li>
              <li>Mathematics as a living, unfinished adventure</li>
              <li>The invitation: these problems are waiting for someone, and it could be you</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 18 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">18</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;The Mathematics of Games: Strategy, Equilibrium, and the Art of Outsmarting Everyone&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Advanced</span>
          </div>
          <p class="lecture-abstract">Every negotiation you have ever had &mdash; from splitting dessert with a sibling to bidding on a house &mdash; is a game in the mathematical sense. Game theory gives us the rigorous language to analyze strategic interactions where your best move depends on what everyone else does. And in finance, where billions of dollars flow through auctions, trading floors, and regulatory frameworks, game theory is not optional &mdash; it is survival.<br><br>We begin with John Nash&rsquo;s thunderbolt: the Nash Equilibrium. We will prove its existence using Brouwer&rsquo;s fixed-point theorem &mdash; a topological result that says every continuous function from a disk to itself has a point that stays put. From this single theorem, an entire theory of strategic behavior unfolds. We will compute equilibria by hand for simple games, see why the Prisoner&rsquo;s Dilemma explains market collusion failures, and discover why Nash&rsquo;s Beautiful Mind earned both a Nobel Prize and a Hollywood film.<br><br>Then we go deeper: mechanism design &mdash; the &ldquo;inverse game theory&rdquo; that asks not &ldquo;what will players do?&rdquo; but &ldquo;what rules should we write so that selfish players produce good outcomes?&rdquo; We will derive the Vickrey auction (why bidding your true value is optimal in a second-price auction &mdash; a clean dominant-strategy proof) and see how the Dubai Financial Market uses mechanism design principles for IPO allocation. For the finale: the revelation principle, which proves that any outcome achievable by any mechanism can also be achieved by one where everyone simply tells the truth. This is a theorem so powerful it won the 2007 Nobel Prize.<br><br>You will leave understanding why the UAE&rsquo;s spectrum auctions, financial market microstructure, and even smart contract design on blockchain all rest on theorems proved by mathematicians who were just playing games.</p>
          <div class="lecture-topics">
            <h4>Key Mathematics</h4>
            <ul>
              <li>Nash Equilibrium: definition, existence proof via Brouwer&rsquo;s fixed-point theorem</li>
              <li>Pure vs. mixed strategies: the minimax theorem</li>
              <li>Prisoner&rsquo;s Dilemma and repeated games: cooperation and defection dynamics</li>
              <li>Mechanism design: the &ldquo;inverse game theory&rdquo; framework</li>
              <li>Vickrey auctions: second-price sealed-bid, dominant strategy truthfulness proof</li>
              <li>The Revelation Principle: formal statement and proof sketch</li>
              <li>Auction theory: English, Dutch, first-price, second-price &mdash; revenue equivalence</li>
              <li>Applications: market microstructure, spectrum auctions, smart contracts</li>
              <li>Connection to evolutionary game theory: replicator dynamics</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 19 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">19</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;The Shape of Data: How Topology Finds Hidden Structure in Financial Markets&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Advanced</span>
          </div>
          <p class="lecture-abstract">What shape is a stock market crash? It sounds like a strange question &mdash; crashes are events, not shapes. But in the last decade, mathematicians discovered that treating financial data as a geometric object and studying its <em>topology</em> &mdash; holes, loops, and voids &mdash; reveals patterns that traditional statistics completely misses. This is Topological Data Analysis, and it is one of the most exciting frontiers in applied mathematics.<br><br>We begin with the fundamental insight: data has shape. A cloud of points in high-dimensional space &mdash; say, daily returns for 50 UAE stocks &mdash; is not just a cloud. It has clusters (connected components), loops (cyclical dependencies), and higher-dimensional voids. Topological Data Analysis (TDA) detects these features using a construction called a simplicial complex. We will build one from scratch: start with data points, draw edges between nearby points, fill in triangles, and watch a topological space emerge from raw numbers.<br><br>The key tool is persistent homology. As we vary the distance threshold for drawing edges, topological features are born and die. Features that persist across many thresholds are &ldquo;real&rdquo; structure; features that flicker briefly are noise. We will compute persistence diagrams by hand for a small dataset and prove that they are stable &mdash; small perturbations in data produce small changes in the diagram (a result that required deep algebraic topology to establish).<br><br>Then we turn to finance. Researchers at Oxford and TU Munich have shown that persistent homology detects early warning signals of market crashes &mdash; the topology of correlation networks changes <em>before</em> the crash happens, creating loops and higher-dimensional holes that vanish in calm markets. We will see this applied to UAE market data from the Abu Dhabi Securities Exchange, where topological signatures preceded the 2020 and 2022 market disruptions.<br><br>We close with the deep mathematical connection: TDA sits at the intersection of algebraic topology, computational geometry, and statistics. The Betti numbers ($\beta_0$ for connected components, $\beta_1$ for loops, $\beta_2$ for voids) quantify the shape of data at every scale. For a generation raised on AI, this is a powerful reminder: not all insight comes from neural networks. Sometimes the deepest patterns are not in the numbers themselves, but in the <em>shape</em> they make.</p>
          <div class="lecture-topics">
            <h4>Key Mathematics</h4>
            <ul>
              <li>Simplicial complexes: vertices, edges, triangles, higher simplices</li>
              <li>Homology groups: $H_0$ (components), $H_1$ (loops), $H_2$ (voids)</li>
              <li>Betti numbers: $\beta_k = \text{rank}(H_k)$ as topological invariants</li>
              <li>Persistent homology: filtrations, birth-death pairs, persistence diagrams</li>
              <li>Stability theorem: Lipschitz continuity of persistence diagrams</li>
              <li>Vietoris-Rips and Cech complexes: two approaches to building topology from data</li>
              <li>Application: crash detection via correlation network topology</li>
              <li>Connection to algebraic topology: chain complexes, boundary operators</li>
              <li>TDA vs. traditional statistics: what topology sees that correlation misses</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== ACT IV: NARRATIVES (20-29) ==================== -->

      <!-- ==================== LECTURE 20 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">20</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;How ChatGPT Learned to Talk: A Mathematical Odyssey from Counting Words to Understanding Them&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Keynote</span>
          </div>
          <p class="lecture-abstract">In 2003, Yoshua Bengio published a paper with a radical idea: what if, instead of treating words as discrete symbols, we represented them as points in continuous space? His neural language model was slow, fragile, and could barely finish a sentence. Two decades later, GPT-4 writes poetry, passes bar exams, and debates philosophy. This lecture tells the mathematical story of how we got from there to here &mdash; not as a survey of technology, but as a narrative of human ideas building on human ideas, each one a leap of mathematical imagination.<br><br><strong>Act One: The Representation Problem.</strong> Language is discrete; mathematics is continuous. Bengio&rsquo;s breakthrough was to embed words into $\mathbb{R}^d$ &mdash; a continuous vector space where &ldquo;king minus man plus woman equals queen&rdquo; becomes literal vector arithmetic. We will derive why this works: the distributional hypothesis (words in similar contexts have similar meanings) creates a structure that linear algebra can exploit. We will see how word2vec&rsquo;s skip-gram model &mdash; published by Tomas Mikolov in 2013, a paper so influential it has over 40,000 citations &mdash; compresses co-occurrence statistics into dense vectors via a shallow neural network whose loss function is secretly doing matrix factorization (we will prove this equivalence).<br><br><strong>Act Two: The Architecture Revolution.</strong> For four years after word2vec, language models used recurrent neural networks that processed words one at a time, left to right, like reading through a keyhole. In June 2017, eight Google researchers published &ldquo;Attention Is All You Need.&rdquo; The transformer replaced recurrence with parallel attention &mdash; and you already know the mathematics from Lecture 8. But here we tell the <em>human</em> story: how Ashish Vaswani was trying to speed up translation, how the team almost did not publish it, how the name &ldquo;transformer&rdquo; was a last-minute choice. We will focus on the mathematical idea they introduced that Lecture 8 did not emphasize: the transformer as a universal sequence-to-sequence function approximator, and the theoretical results (from 2020&ndash;2024) proving that transformers can simulate Turing machines.<br><br><strong>Act Three: Scaling and Emergence.</strong> The strangest chapter. When GPT-2 (1.5 billion parameters) was trained, it learned to write coherent paragraphs. When GPT-3 (175 billion) was trained on essentially the same architecture, it learned to do arithmetic, translate languages it was never explicitly taught, and write code. These &ldquo;emergent abilities&rdquo; appeared at specific scale thresholds &mdash; and nobody knows why. We will examine the scaling laws (Kaplan et al. 2020, Hoffmann et al. 2022) as empirical power laws and ask: is there a mathematical theory that explains them? The honest answer is no &mdash; and this is one of the great open questions in AI.</p>
          <div class="lecture-topics">
            <h4>Key Themes</h4>
            <ul>
              <li>Bengio&rsquo;s 2003 neural language model: the seed of an idea</li>
              <li>Word2vec and the distributional hypothesis: linear algebra of meaning</li>
              <li>The skip-gram to matrix factorization equivalence (proof)</li>
              <li>The transformer story: human drama behind &ldquo;Attention Is All You Need&rdquo;</li>
              <li>Transformers as universal approximators: theoretical results</li>
              <li>Scaling laws as empirical power laws: what we know and what we do not</li>
              <li>Emergent abilities and phase transitions: the great open question</li>
              <li>From counting words to &ldquo;understanding&rdquo; them: what changed, mathematically?</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 21 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">21</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;The Hallucination Problem: Why AI Confidently Says Things That Are Not True&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Keynote</span>
          </div>
          <p class="lecture-abstract">In June 2023, a lawyer submitted a legal brief to a New York court citing six precedent cases. None of them existed. ChatGPT had invented them &mdash; complete with case numbers, judges&rsquo; names, and plausible-sounding legal arguments. The lawyer was sanctioned. The AI was unapologetic. This is the hallucination problem, and it is not a bug that engineers will fix with the next update. It is a <em>mathematical</em> phenomenon rooted in how these models fundamentally work.<br><br><strong>The Story of Overconfidence.</strong> A language model is, at its core, a next-token probability distribution: $P(x_{t+1} \mid x_1, \ldots, x_t)$. It has been trained on billions of tokens to minimize cross-entropy loss. When it generates text, it samples from this distribution. But here is the mathematical trap: the training objective rewards <em>fluency</em> (high probability sequences), not <em>truth</em>. A perfectly fluent sentence about a nonexistent court case scores just as well as a true one during training. We will formalize this gap between calibration (does the model&rsquo;s confidence match reality?) and accuracy (is the output correct?), and prove that cross-entropy training does not guarantee calibration in the out-of-distribution regime.<br><br><strong>The Mathematics of Not Knowing.</strong> The deeper question: can we make AI <em>know when it does not know</em>? This turns out to be a rich mathematical problem. We will trace three approaches. First: Bayesian uncertainty, where instead of learning a single model, you maintain a distribution over models &mdash; the posterior predictive distribution naturally captures epistemic uncertainty, but computing it exactly is intractable. Second: conformal prediction &mdash; a framework that provides <em>distribution-free</em> prediction sets with guaranteed coverage: &ldquo;I am 95% confident the answer is in this set.&rdquo; We will derive the basic conformal guarantee (a beautiful application of exchangeability). Third: the information-theoretic approach &mdash; measuring surprise via the model&rsquo;s own entropy and detecting when the model is &ldquo;making things up.&rdquo;<br><br><strong>Why This Problem May Be Unsolvable.</strong> We close with a provocative argument: for any system that generates creative, open-ended text, perfect hallucination detection may be undecidable &mdash; a consequence of the fact that distinguishing &ldquo;plausible but false&rdquo; from &ldquo;plausible and true&rdquo; requires access to ground truth that the model, by construction, does not have. This connects back to G&ouml;del&rsquo;s limits from Lecture 15.</p>
          <div class="lecture-topics">
            <h4>Key Themes</h4>
            <ul>
              <li>The lawyer and the fake cases: a story that shocked the legal world</li>
              <li>Language models as probability distributions: why fluency does not imply truth</li>
              <li>Calibration vs. accuracy: formal definitions and the gap between them</li>
              <li>Bayesian uncertainty: posterior predictive distributions and intractability</li>
              <li>Conformal prediction: distribution-free guarantees from exchangeability</li>
              <li>Attention entropy and perplexity as hallucination signals</li>
              <li>The undecidability argument: fundamental limits on self-knowledge</li>
              <li>Connections to G&ouml;del (Lecture 15) and the limits of formal systems</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 22 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">22</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;The Code That Won the War: Turing, Enigma, and the Birth of Computer Science&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Keynote</span>
          </div>
          <p class="lecture-abstract">In the winter of 1940, German U-boats were sinking Allied supply ships at a rate that would have starved Britain into surrender within months. The only hope was to break Enigma &mdash; the German cipher machine that produced $158,962,555,217,826,360,000$ possible settings each day. The person who broke it was a 27-year-old Cambridge mathematician named Alan Turing. This lecture tells the story of how pure mathematical logic defeated a military superpower &mdash; and, in doing so, created the theoretical foundations of every computer and every AI system that exists today.<br><br><strong>Act One: The Machine.</strong> We begin with Enigma itself &mdash; a cipher machine that implements a polyalphabetic substitution via rotors, a plugboard, and a reflector. We will formalize its operation as a composition of permutations in the symmetric group $S_{26}$, compute the size of the keyspace, and see why brute force was impossible even for an army of mathematicians. The genius of Enigma was not any single component but their <em>composition</em> &mdash; and we will show how group theory provides the natural language for analyzing composed permutations.<br><br><strong>Act Two: The Breakthrough.</strong> Turing&rsquo;s insight was not to try every key but to exploit a mathematical weakness: the reflector guaranteed that no letter could encrypt to itself. This single constraint &mdash; a fixed-point-free permutation &mdash; was enough to build the Bombe, an electromechanical device that used logical contradiction to eliminate impossible keys at astonishing speed. We will formalize Turing&rsquo;s method as a constraint satisfaction problem and prove why the fixed-point-free property reduces the search space exponentially. We will also tell the human story: Turing working in Hut 8 at Bletchley Park, the eccentric habits, the race against time.<br><br><strong>Act Three: The Legacy.</strong> Turing&rsquo;s wartime work was classified for decades. But before the war, in 1936, he had published something even more profound: the concept of a Turing machine &mdash; a mathematical abstraction that defines what &ldquo;computation&rdquo; means. We will construct a Turing machine, prove the existence of a universal Turing machine, and see why this single idea is the foundation of all of computer science. We close with Turing&rsquo;s tragic personal story and his posthumous pardon in 2013.</p>
          <div class="lecture-topics">
            <h4>Key Themes</h4>
            <ul>
              <li>Enigma as permutation composition in $S_{26}$: the group theory of encryption</li>
              <li>Keyspace computation: why brute force fails at $10^{20}$ scale</li>
              <li>Turing&rsquo;s insight: fixed-point-free permutations and constraint propagation</li>
              <li>The Bombe: logical contradiction as a search strategy</li>
              <li>The human story: Bletchley Park, Hut 8, and the race against U-boats</li>
              <li>Turing machines: what &ldquo;computation&rdquo; means, formally</li>
              <li>Universal Turing machines and the Church-Turing thesis</li>
              <li>Turing&rsquo;s legacy: from codebreaking to the foundations of AI</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 23 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">23</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;From Al-Khwarizmi to Algorithms: The Mathematical Heritage That Runs the World&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Keynote</span>
          </div>
          <p class="lecture-abstract">The word &ldquo;algorithm&rdquo; comes from the name of a 9th-century Persian mathematician: Muhammad ibn Musa al-Khwarizmi. The word &ldquo;algebra&rdquo; comes from the title of his book: <em>Al-Kitab al-Mukhtasar fi Hisab al-Jabr wal-Muqabala</em>, written in Baghdad around 820 CE. Every time a search engine ranks results, every time an AI model trains, every time a GPS finds the shortest route &mdash; it is running an algorithm, a word that literally means &ldquo;in the manner of al-Khwarizmi.&rdquo; This lecture tells the story of the Islamic Golden Age&rsquo;s mathematical revolution and traces its unbroken line to the AI systems of today.<br><br><strong>The Baghdad Renaissance.</strong> Between roughly 750 and 1258 CE, Baghdad&rsquo;s House of Wisdom was the intellectual center of the world. We will meet al-Khwarizmi, who classified all six types of quadratic equations and provided geometric proofs for each. We will reconstruct his geometric proof that $x^2 + 10x = 39$ has solution $x = 3$ by literally completing a square &mdash; the origin of the technique you learned in school. We will meet Omar Khayyam, who solved cubic equations using the intersection of conic sections three centuries before Cardano.<br><br><strong>The Transmission.</strong> How did this mathematics reach Europe? Through translation. In 12th-century Toledo, scholars translated Arabic mathematical texts into Latin. Fibonacci learned the Hindu-Arabic numeral system from North African mathematicians and introduced it to Europe in 1202. We will show how the positional number system &mdash; where the symbol &ldquo;0&rdquo; makes place value possible &mdash; is itself a mathematical technology so profound that without it, neither calculus nor computation could exist.<br><br><strong>The Living Legacy.</strong> We will trace direct lines from Golden Age mathematics to modern AI. Al-Khwarizmi&rsquo;s &ldquo;recipe-based&rdquo; problem solving is the ancestor of every algorithm. The Islamic geometric tradition &mdash; the tessellations of the Alhambra, which encode all 17 wallpaper groups &mdash; connects to group theory, symmetry detection in computer vision, and the equivariance properties of modern neural networks. We close in the UAE, where this mathematical heritage is alive: Abu Dhabi&rsquo;s Louvre displays geometric patterns encoding the same group theory that powers the AI systems being built across the street at TII.</p>
          <div class="lecture-topics">
            <h4>Key Themes</h4>
            <ul>
              <li>Al-Khwarizmi&rsquo;s classification of quadratic equations: geometric proofs reconstructed</li>
              <li>Omar Khayyam&rsquo;s cubic solutions via conic intersections</li>
              <li>The House of Wisdom: Baghdad as the world&rsquo;s intellectual center (750&ndash;1258 CE)</li>
              <li>The transmission: Toledo translations, Fibonacci, and the Hindu-Arabic numerals</li>
              <li>The story of zero: from India through Baghdad to the world</li>
              <li>Islamic geometric art and the 17 wallpaper groups: symmetry before group theory</li>
              <li>Al-Khalil&rsquo;s combinatorics: permutation enumeration as proto-computer science</li>
              <li>Direct lines to modern AI: algorithms, symmetry, combinatorial optimization</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 24 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">24</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;Chaos, Butterflies, and the Death of Prediction: When Mathematics Discovered Uncertainty&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Keynote</span>
          </div>
          <p class="lecture-abstract">In 1961, a meteorologist named Edward Lorenz was running a weather simulation on a Royal McBee computer. To save time, he restarted a run from the middle, typing in values rounded to three decimal places instead of the six stored internally. The difference was one part in ten thousand. The result was a completely different weather pattern. Lorenz had accidentally discovered chaos &mdash; and in doing so, killed the dream of perfect prediction that had sustained science since Newton.<br><br><strong>Act One: The Dream of Laplace.</strong> In 1814, Pierre-Simon Laplace articulated the ultimate scientific fantasy: a being that knew the position and velocity of every particle in the universe could predict the entire future. We will formalize this: given a system $\dot{\mathbf{x}} = \mathbf{f}(\mathbf{x})$ with known initial conditions, the solution is uniquely determined (Picard-Lindel&ouml;f theorem). So where does prediction fail?<br><br><strong>Act Two: Sensitive Dependence.</strong> Lorenz&rsquo;s system &mdash; three simple ODEs modeling atmospheric convection &mdash; is fully deterministic. Yet two solutions starting $10^{-4}$ apart diverge exponentially: $\|\delta\mathbf{x}(t)\| \sim \|\delta\mathbf{x}(0)\| e^{\lambda t}$, where $\lambda > 0$ is the Lyapunov exponent. We will compute $\lambda$ for the Lorenz system and show that this single number quantifies the &ldquo;butterfly effect.&rdquo; For Earth&rsquo;s atmosphere, this gives roughly 10&ndash;14 days &mdash; the fundamental limit of weather forecasting, no matter how powerful your computer. We will plot the Lorenz attractor and see its hauntingly beautiful butterfly shape.<br><br><strong>Act Three: Chaos Everywhere.</strong> The logistic map $x_{n+1} = rx_n(1-x_n)$ &mdash; a one-line equation producing period-doubling cascades and the universal Feigenbaum constant $\delta \approx 4.669$. Poincar&eacute;&rsquo;s proof that the three-body problem is chaotic. And the unresolved question: are financial markets stochastic or chaotic? We close with an open question: can neural networks extend prediction horizons beyond the theoretical Lyapunov limit?</p>
          <div class="lecture-topics">
            <h4>Key Themes</h4>
            <ul>
              <li>Lorenz&rsquo;s accidental discovery: the printout, the rounding, the divergence</li>
              <li>Laplace&rsquo;s Demon and the Picard-Lindel&ouml;f theorem: determinism is not prediction</li>
              <li>Lyapunov exponents: quantifying the butterfly effect</li>
              <li>The Lorenz attractor: strange attractors and fractal dimension</li>
              <li>The logistic map and Feigenbaum universality: chaos from one line</li>
              <li>Poincar&eacute; and the three-body problem: why exact celestial mechanics died</li>
              <li>Chaos in financial markets: testing for deterministic structure in prices</li>
              <li>AI vs. chaos: can neural networks extend the prediction horizon?</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 25 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">25</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;The Woman Who Invented the Future: Emmy Noether and the Hidden Architecture of Physics&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Keynote</span>
          </div>
          <p class="lecture-abstract">In 1915, two of the greatest mathematicians alive &mdash; David Hilbert and Felix Klein &mdash; invited Emmy Noether to the University of G&ouml;ttingen to solve a problem that was defeating them both. Einstein&rsquo;s new general theory of relativity seemed to violate conservation of energy. Noether, then 33, solved it in a few months with a theorem so profound that physicists consider it one of the most important results in the history of science. Yet she was denied a faculty position because she was a woman, was paid nothing for years, and when she died at 53, Einstein wrote that she was &ldquo;the most significant creative mathematical genius thus far produced since the higher education of women began.&rdquo;<br><br><strong>The Theorem.</strong> Noether&rsquo;s theorem states: for every continuous symmetry of a physical system, there is a corresponding conserved quantity. Time symmetry gives conservation of energy. Spatial symmetry gives conservation of momentum. We will state and prove a simplified version using the calculus of variations: for a Lagrangian invariant under a one-parameter group of transformations, the corresponding Noether charge is conserved along solutions of the Euler-Lagrange equations.<br><br><strong>The Revolution in Algebra.</strong> Noether essentially invented modern abstract algebra. Before her, algebra was about solving equations. After her, algebra was about <em>structures</em>: rings, ideals, modules. Her ascending chain condition on ideals (Noetherian rings) unified vast territories of algebra and algebraic geometry under a single framework. Her approach &mdash; strip away specifics, find essential structure, prove at maximum generality &mdash; is the methodology modern mathematics runs on.<br><br><strong>The Living Legacy.</strong> Noether&rsquo;s ideas are everywhere in modern AI. The equivariance properties of convolutional neural networks and graph neural networks (Lecture 12) are applications of symmetry groups &mdash; Noether&rsquo;s intellectual territory. We draw the line from a woman denied a salary in 1915 to the cutting-edge AI architectures of 2026.</p>
          <div class="lecture-topics">
            <h4>Key Themes</h4>
            <ul>
              <li>Emmy Noether&rsquo;s biography: prejudice, perseverance, and genius</li>
              <li>Noether&rsquo;s theorem: symmetry implies conservation (proof via calculus of variations)</li>
              <li>Time symmetry and energy, space symmetry and momentum: examples derived</li>
              <li>The revolution in algebra: from solving equations to studying structures</li>
              <li>Noetherian rings: the ascending chain condition and why it matters</li>
              <li>The Noetherian methodology: abstraction as power</li>
              <li>Symmetry in AI: equivariance in CNNs, GNNs, and gauge networks</li>
              <li>The question of recognition: whose names mathematics remembers</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 26 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">26</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;Why Does Deep Learning Work? The Greatest Unsolved Problem in AI&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Keynote</span>
          </div>
          <p class="lecture-abstract">Here is a scandal at the heart of artificial intelligence: the most powerful technology of our era works for reasons we do not fully understand. Deep learning <em>should not</em> work. Classical statistical theory says it should overfit catastrophically. It has more parameters than data points, its loss landscape defies visualization, and yet it generalizes spectacularly. This lecture tells the story of our attempts to understand why &mdash; and the mathematical mysteries that remain open.<br><br><strong>The Overfitting Paradox.</strong> Classical learning theory (Vapnik-Chervonenkis theory) says a model&rsquo;s test error is bounded by training error plus a complexity penalty that grows with parameter count. For a network with 175 billion parameters, this bound is vacuous &mdash; it predicts performance no better than random guessing. Yet GPT-4 generalizes beautifully. Something in the classical theory is fundamentally wrong. We will state the VC bound precisely and stare at the absurd gap between theory and practice.<br><br><strong>Double Descent.</strong> In 2019, researchers discovered that as model complexity increases past the interpolation threshold, test error <em>decreases again</em>. The classical U-shaped bias-variance tradeoff has a second phase. We will formalize this via minimum-norm interpolators and connect it to the implicit bias of gradient descent toward flat minima using PAC-Bayes bounds.<br><br><strong>The Lottery Ticket Hypothesis.</strong> Inside every trained network exists a tiny subnetwork (1&ndash;5% of the original) that achieves the same performance when trained in isolation. Overparameterization is not about using all parameters &mdash; it makes the optimization landscape navigable enough to <em>find</em> the good subnetwork.<br><br><strong>What We Still Do Not Know.</strong> Why does SGD find generalizing solutions? Why do large models exhibit &ldquo;grokking&rdquo; &mdash; memorizing data for thousands of epochs before suddenly learning the pattern? Why do neural scaling laws follow power laws? Each is a frontier research problem. The most successful technology in a generation is running ahead of our theoretical understanding.</p>
          <div class="lecture-topics">
            <h4>Key Themes</h4>
            <ul>
              <li>The scandal: deep learning works despite violating classical theory</li>
              <li>VC dimension and the generalization bound: precise statement and vacuousness</li>
              <li>Double descent: the death of the bias-variance tradeoff U-curve</li>
              <li>Minimum-norm interpolation and implicit regularization by gradient descent</li>
              <li>The lottery ticket hypothesis: sparse subnetworks and overparameterization</li>
              <li>Grokking: delayed generalization after memorization</li>
              <li>Neural scaling laws: empirical power laws without theoretical explanation</li>
              <li>The great open question: why does deep learning generalize?</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 27 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">27</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;Information, Entropy, and the Arrow of Time: When Two Equations Turned Out to Be the Same&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Keynote</span>
          </div>
          <p class="lecture-abstract">In 1948, Claude Shannon was trying to measure information. In 1877, Ludwig Boltzmann was trying to measure disorder in a gas. Working seventy years apart, in completely different fields, they wrote down the same equation: $H = -\sum p_i \log p_i$. The joke Shannon reportedly told &mdash; &ldquo;No one really knows what entropy is, so in a debate you will always have the advantage&rdquo; &mdash; hides a deep truth: information and thermodynamics <em>are</em> connected, and the connection runs far deeper than a shared formula.<br><br><strong>Act One: Boltzmann&rsquo;s Entropy.</strong> In the 1870s, Boltzmann proposed that the entropy of a gas was a <em>counting problem</em>: $S = k_B \ln W$, where $W$ is the number of microstates consistent with a macroscopic observation. This was radical: it reduced thermodynamics to combinatorics. We will derive the formula, show how Stirling&rsquo;s approximation transforms it into $S = -k_B \sum p_i \ln p_i$, and understand why entropy always increases &mdash; the Second Law as a statement about the overwhelming probability of disordered states.<br><br><strong>Act Two: Shannon&rsquo;s Entropy.</strong> Shannon needed a measure of &ldquo;surprise&rdquo; in a random variable. Starting from three axioms &mdash; continuity, monotonicity, and additivity for independent events &mdash; he proved the <em>unique</em> measure satisfying all three is $H = -\sum p_i \log_2 p_i$. We will reproduce Shannon&rsquo;s uniqueness proof (it uses the functional equation for logarithms and is surprisingly elegant).<br><br><strong>Act Three: The Deep Connection.</strong> In 1961, Rolf Landauer proved that erasing one bit of information <em>must</em> dissipate at least $k_B T \ln 2$ joules of heat. Information is physical. Maxwell&rsquo;s Demon is defeated by Landauer&rsquo;s principle: the demon must erase its memory, and that erasure produces entropy.<br><br><strong>The AI Connection.</strong> Cross-entropy loss, KL divergence, maximum entropy &mdash; Shannon&rsquo;s entropy is everywhere in modern AI. We close by noting that Landauer&rsquo;s principle sets the ultimate physical limit on computation &mdash; and we are nowhere near it, but the direction matters.</p>
          <div class="lecture-topics">
            <h4>Key Themes</h4>
            <ul>
              <li>Boltzmann&rsquo;s entropy: reducing thermodynamics to combinatorics</li>
              <li>The Second Law as a probability statement, not a physical law</li>
              <li>Shannon&rsquo;s entropy: the uniqueness proof from three axioms</li>
              <li>The bit: the fundamental unit of information</li>
              <li>Landauer&rsquo;s principle: erasing information has thermodynamic cost</li>
              <li>Maxwell&rsquo;s Demon: defeated by information theory</li>
              <li>The deep connection: why the formulas are the same</li>
              <li>Cross-entropy loss, KL divergence, maximum entropy in AI</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 28 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">28</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;The Alignment Problem: Can We Mathematically Guarantee That AI Does What We Want?&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Keynote</span>
          </div>
          <p class="lecture-abstract">In 2016, researchers at OpenAI trained a reinforcement learning agent to play a boat racing game. The agent discovered that instead of finishing the race, it could earn more points by driving in circles, hitting boost pads, and catching fire repeatedly. It maximized the reward function perfectly &mdash; and did not even try to win. This comical failure illustrates the most important unsolved problem in AI safety: the alignment problem.<br><br><strong>Act One: Goodhart&rsquo;s Law, Formalized.</strong> &ldquo;When a measure becomes a target, it ceases to be a good measure.&rdquo; Let $R^*$ be the true reward and $\hat{R}$ the proxy we specify. The regret $\sum_t [R^*(s_t, a_t) - \hat{R}(s_t, a_t)]$ can grow without bound even as $\hat{R}$ is maximized &mdash; and we will prove conditions under which this divergence is guaranteed. The boat racing agent is amusing. An AI managing a power grid is not.<br><br><strong>Act Two: RLHF.</strong> The current solution: learn rewards from human preferences. A human picks the better of two outputs. We fit a reward model via the Bradley-Terry model: $P(A \succ B) = \sigma(R(A) - R(B))$. We derive the loss function, prove Bradley-Terry consistency, and see PPO for fine-tuning. But RLHF has its own failure: reward hacking, where the policy exploits the reward model&rsquo;s errors.<br><br><strong>Act Three: The Deeper Problem.</strong> We cannot even <em>specify</em> what we want mathematically. Human values are inconsistent (Arrow&rsquo;s impossibility theorem, connecting to Lecture 6). And the most dangerous scenario &mdash; an AI smarter than its overseers &mdash; raises questions we do not know how to formalize. We examine mesa-optimization, deceptive alignment, and the mathematical frameworks (cooperative inverse RL, debate-based alignment) being developed to address these risks.</p>
          <div class="lecture-topics">
            <h4>Key Themes</h4>
            <ul>
              <li>The boat racing agent: reward hacking in action</li>
              <li>Goodhart&rsquo;s Law formalized: proxy divergence under optimization pressure</li>
              <li>RLHF: the Bradley-Terry model and its derivation</li>
              <li>PPO for fine-tuning: how ChatGPT learns from human preferences</li>
              <li>Reward hacking: when the learned reward model is exploited</li>
              <li>Arrow&rsquo;s impossibility theorem: why specifying values is mathematically hard</li>
              <li>Mesa-optimization and deceptive alignment: AI systems with hidden goals</li>
              <li>Open question: can we ever mathematically guarantee alignment?</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 29 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">29</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;Music, Fourier, and the Mathematics of Everything You Hear&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Keynote</span>
          </div>
          <p class="lecture-abstract">In 1807, Joseph Fourier submitted a paper to the French Academy of Sciences claiming that any function &mdash; no matter how wild, no matter how discontinuous &mdash; could be written as a sum of sines and cosines. The referees, who included Lagrange and Laplace, rejected it. Lagrange reportedly said it was &ldquo;impossible.&rdquo; They were wrong. Fourier was right. And his idea became arguably the most widely applied mathematical idea in all of science and engineering.<br><br><strong>Act One: The Vibrating String.</strong> A vibrating guitar string produces a fundamental frequency and overtones. We will derive the wave equation, solve it by separation of variables, and find that the solutions are $\sin(n\pi x/L)$ &mdash; the Fourier basis. The key insight: these functions are <em>orthogonal</em> under the inner product $\langle f, g \rangle = \int_0^L f(x)g(x)\,dx$, and orthogonality is what makes decomposition possible. This is the same linear algebra from Lecture 1, now applied to infinite-dimensional function spaces.<br><br><strong>Act Two: The Fourier Transform.</strong> From Fourier series to the Fourier transform: $\hat{f}(\omega) = \int_{-\infty}^{\infty} f(t) e^{-2\pi i \omega t}\,dt$. We will prove Parseval&rsquo;s theorem (energy conservation between time and frequency) and derive Heisenberg&rsquo;s uncertainty principle in its mathematical form: $\Delta t \cdot \Delta \omega \geq \frac{1}{4\pi}$. This is not quantum mechanics &mdash; this is pure Fourier analysis.<br><br><strong>Act Three: From Vibrating Strings to Voice Assistants.</strong> The Fast Fourier Transform (Cooley-Tukey 1965, though Gauss had a version in 1805) computes the DFT in $O(n \log n)$ instead of $O(n^2)$. We will derive the butterfly structure of the FFT. Then we follow Fourier into AI: speech recognition converts sound to spectrograms via the Short-Time Fourier Transform, then feeds these to neural networks. MP3 compression uses the modified discrete cosine transform to discard frequencies your ear cannot perceive. We compute the compression ratio and see why a 50MB WAV becomes a 5MB MP3: the mathematics of human perception meets function decomposition.</p>
          <div class="lecture-topics">
            <h4>Key Themes</h4>
            <ul>
              <li>Fourier&rsquo;s rejected paper: the story of an idea too radical for its time</li>
              <li>The wave equation and separation of variables: deriving the Fourier basis</li>
              <li>Orthogonality in function spaces: infinite-dimensional linear algebra</li>
              <li>The Fourier transform: from series to integrals, Parseval&rsquo;s theorem</li>
              <li>Heisenberg&rsquo;s uncertainty principle as a theorem about functions</li>
              <li>The FFT algorithm: the butterfly structure and $O(n \log n)$ derivation</li>
              <li>Spectrograms, speech recognition, and voice assistants: Fourier in AI</li>
              <li>MP3 compression: discarding what you cannot hear</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== ACT V: THE LLM REVOLUTION (30-39) ==================== -->

      <!-- ==================== LECTURE 30 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">30</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;When AI Won the Nobel Prize: The Mathematics That Taught Machines to Think&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Keynote</span>
          </div>
          <p class="lecture-abstract">In October 2024, something happened that no one had predicted &mdash; not even the laureates themselves. The Nobel Prize in Physics went to Geoffrey Hinton and John Hopfield for the mathematical foundations of artificial neural networks. Days later, the Nobel Prize in Chemistry went to Demis Hassabis and John Jumper for using AI to solve protein structure prediction. For the first time in history, artificial intelligence did not just assist science &mdash; it <em>was</em> the science. These awards mark the moment when the mathematics of learning crossed from engineering curiosity to fundamental contribution to human knowledge.<br><br><strong>Act One: The Physicist Who Gave Machines Memory.</strong> In 1982, John Hopfield &mdash; a physicist, not a computer scientist &mdash; asked a peculiar question: could a network of simple binary units store and retrieve memories the way a magnet stores its orientation? His answer was the Hopfield network, defined by an energy function $E = -\sum_{i,j} w_{ij} s_i s_j$ where $s_i \in \{-1, +1\}$ are neuron states and $w_{ij}$ are connection weights. Memory retrieval becomes energy minimization &mdash; the network rolls downhill in an energy landscape until it settles into a stored pattern. We will prove that this dynamics always converges (the energy decreases at every step) and derive the storage capacity: a network of $n$ neurons can reliably store approximately $0.14n$ patterns. Geoffrey Hinton then extended Hopfield&rsquo;s ideas into Boltzmann machines, introducing stochastic neurons that sample from $P(s_i = 1) = \sigma(\sum_j w_{ij} s_j)$ where $\sigma$ is the sigmoid function. This was the seed of deep learning &mdash; and Hinton spent forty years nurturing it while most of academia dismissed neural networks as a dead end.<br><br><strong>Act Two: The Chess Prodigy Who Solved Biology&rsquo;s Hardest Problem.</strong> Demis Hassabis was a chess prodigy at age four, a game designer at seventeen, and earned a PhD in neuroscience from University College London. In 2010, he founded DeepMind with a mission to &ldquo;solve intelligence, and then use that to solve everything else.&rdquo; The &ldquo;everything else&rdquo; turned out to be protein folding &mdash; predicting a protein&rsquo;s three-dimensional structure from its amino acid sequence. This problem had resisted fifty years of effort. AlphaFold, designed by Hassabis and John Jumper, used attention mechanisms to model pairwise distances between amino acid residues, treating protein structure prediction as a geometric optimization problem in $\mathbb{R}^3$. In 2020, AlphaFold achieved a median GDT score of 92.4 (out of 100) at the CASP14 competition, essentially solving the problem. By 2024, AlphaFold had predicted the structure of over 200 million proteins &mdash; virtually every protein known to science.<br><br><strong>Act Three: When Physics Meets Information.</strong> The deep connection: both Nobel Prizes recognized that the mathematics of statistical physics &mdash; energy landscapes, partition functions, free energy minimization &mdash; is also the mathematics of learning. Hopfield networks minimize an energy function; modern neural networks minimize a loss function. Boltzmann machines sample from a Gibbs distribution $P(\mathbf{s}) = e^{-E(\mathbf{s})}/Z$; variational autoencoders minimize a free energy bound. The mathematics does not care whether you are modeling magnetic spins or protein folds or language &mdash; the same principles of optimization, probability, and geometry apply everywhere. This is why physicists are increasingly moving into AI, and why the Nobel committee decided that artificial intelligence is, at its mathematical core, physics.</p>
          <div class="lecture-topics">
            <h4>Key Themes</h4>
            <ul>
              <li>The 2024 Nobel Prizes in Physics and Chemistry: AI enters the pantheon of science</li>
              <li>Hopfield networks: energy minimization, convergence proof, storage capacity</li>
              <li>Boltzmann machines: stochastic neurons, the sigmoid function, and the birth of deep learning</li>
              <li>Geoffrey Hinton&rsquo;s forty-year persistence: how neural networks went from ridicule to revolution</li>
              <li>AlphaFold: attention mechanisms applied to protein structure prediction in $\mathbb{R}^3$</li>
              <li>Demis Hassabis: from chess prodigy to solving biology&rsquo;s fifty-year grand challenge</li>
              <li>The deep connection: statistical physics and machine learning share the same mathematics</li>
              <li>Free energy, partition functions, and Gibbs distributions: physics as the language of learning</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 31 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">31</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;The Scaling Hypothesis: When Bigger Means Smarter (Or Does It?)&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Keynote</span>
          </div>
          <p class="lecture-abstract">In January 2020, a team of researchers at OpenAI discovered something that would reshape the entire AI industry: intelligence, it seemed, could be bought. Jared Kaplan, Sam McCandlish, and colleagues plotted the test loss of language models against three variables &mdash; the number of parameters, the amount of training data, and the total compute budget &mdash; and found clean power laws. Double the compute, and the loss drops by a predictable amount. Their paper, &ldquo;Scaling Laws for Neural Language Models,&rdquo; became the intellectual foundation for a hundred-billion-dollar bet: if you build it bigger, it will get smarter. But is it true?<br><br><strong>Act One: The Power Laws.</strong> The Kaplan scaling laws take the form $L(C) \approx (C_0/C)^{\alpha_C}$ where $L$ is the test loss, $C$ is the compute budget measured in FLOPs, and $\alpha_C \approx 0.050$ is a remarkably consistent exponent. Similar power laws hold for parameters $N$ and data $D$: $L(N) \approx (N_0/N)^{\alpha_N}$ and $L(D) \approx (D_0/D)^{\alpha_D}$. We will derive why power laws appear so ubiquitously in complex systems &mdash; from Zipf&rsquo;s law in linguistics to Pareto distributions in economics &mdash; and explore the hypothesis that neural network scaling laws arise from the fractal structure of natural data. The practical implication was staggering: you could predict the performance of a model costing $100 million to train by running experiments costing $10,000. OpenAI used this to plan GPT-4 before writing a single line of its training code.<br><br><strong>Act Two: The Chinchilla Revolution.</strong> In 2022, a team at DeepMind led by Jordan Hoffmann delivered a shock. Their paper, known as &ldquo;Chinchilla,&rdquo; showed that most large language models were massively undertrained on data. The Kaplan laws had suggested scaling parameters was most important; Chinchilla proved that compute-optimal training requires scaling data and parameters roughly equally: for a model with $N$ parameters, you need approximately $20N$ training tokens. This meant GPT-3&rsquo;s 175 billion parameters should have been trained on 3.5 trillion tokens, not the 300 billion it actually saw. We will derive the Chinchilla-optimal ratio from first principles using the joint scaling law $L(N, D) = E + A/N^{\alpha} + B/D^{\beta}$ and solve the constrained optimization problem: given a fixed compute budget $C \approx 6ND$, what is the optimal allocation between $N$ and $D$?<br><br><strong>Act Three: The Walls and the Workarounds.</strong> By 2024, the scaling hypothesis faced its reckoning. The &ldquo;data wall&rdquo; loomed: high-quality internet text is finite, and models were approaching the limits of available training data. OpenAI&rsquo;s response was revolutionary &mdash; instead of scaling training-time compute, scale <em>inference-time</em> compute. Their o1 model (September 2024) and o3 model (December 2024) use chain-of-thought reasoning at test time, spending more computation per question rather than per training step. This represents a fundamental shift in the scaling paradigm: from $L(C_{\text{train}})$ to $L(C_{\text{train}}, C_{\text{test}})$. We will analyze the economics: GPT-4 cost approximately $100 million to train, and the math predicts GPT-5 would cost $500 million to $1 billion under the old paradigm. Is test-time scaling the escape hatch, or merely a detour?</p>
          <div class="lecture-topics">
            <h4>Key Themes</h4>
            <ul>
              <li>Kaplan scaling laws: power laws for compute, data, and parameters</li>
              <li>Why power laws appear everywhere: fractal structure and Zipf&rsquo;s law</li>
              <li>The Chinchilla revolution: compute-optimal training and the $20N$ data rule</li>
              <li>Deriving the optimal allocation: constrained optimization of $L(N, D)$</li>
              <li>The data wall: finite high-quality text and the limits of scaling</li>
              <li>Test-time compute: OpenAI&rsquo;s o1 and o3 shift the paradigm from training to inference</li>
              <li>The economics of scale: from $100M for GPT-4 to what the math predicts for GPT-5</li>
              <li>The open question: is scaling all you need, or are we hitting diminishing returns?</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 32 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">32</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;Can Machines Reason? The Mathematics of Chain-of-Thought&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Keynote</span>
          </div>
          <p class="lecture-abstract">In May 2022, Jason Wei &mdash; a researcher at Google Brain &mdash; published a finding so simple it seemed like a prank. If you add the phrase &ldquo;Let&rsquo;s think step by step&rdquo; to a math problem, GPT-style models suddenly get dramatically better at solving it. Accuracy on grade-school math jumped from 18% to 79%. No retraining. No new parameters. Just five words. This discovery &mdash; chain-of-thought prompting &mdash; opened a philosophical abyss: are language models actually <em>reasoning</em>, or are they performing an extraordinarily sophisticated form of pattern matching? Two years later, we still do not have a definitive answer. But the mathematics we have developed to investigate the question is extraordinary.<br><br><strong>Act One: The Prompting Revolution.</strong> Chain-of-thought (CoT) prompting works by providing intermediate reasoning steps as part of the prompt, transforming a single-step prediction $P(y \mid x)$ into a multi-step decomposition $P(y \mid x) = \sum_z P(y \mid z, x) P(z \mid x)$ where $z$ represents the reasoning chain. We will prove a key theoretical result: standard transformers with bounded depth cannot solve certain compositional tasks, but transformers generating intermediate tokens can &mdash; because each generated token effectively adds a layer of computation. The chain-of-thought is not decoration; it is <em>additional compute</em>. This connects to the theory of computational complexity: CoT allows a constant-depth transformer to simulate a polynomial-depth computation, analogous to the difference between $\text{AC}^0$ and $\text{P}$ in circuit complexity.<br><br><strong>Act Two: Training Machines to Think.</strong> OpenAI&rsquo;s o1 model (September 2024) went beyond prompting: it was <em>trained</em> to reason. The key innovation was process reward models (PRMs) &mdash; instead of rewarding only the final answer, the model receives feedback on each intermediate step. Formally, the reward function changes from $R(x, y)$ (outcome-based) to $R(x, z_1, z_2, \ldots, z_n, y)$ (process-based). We will analyze why this matters: outcome reward models suffer from reward hacking &mdash; the model finds shortcuts that produce correct answers without correct reasoning. Process reward models enforce that the <em>path</em> must be valid, not just the destination. We will formalize this as a tree search problem where each node is a reasoning step, and the PRM assigns value estimates to guide exploration &mdash; mathematically identical to the Monte Carlo Tree Search used in AlphaGo.<br><br><strong>Act Three: The Frontier of Machine Reasoning.</strong> In December 2024, OpenAI released o3, which scored 87.5% on the ARC-AGI benchmark &mdash; a test designed by Fran&ccedil;ois Chollet specifically to measure genuine reasoning ability, not memorization. Humans score approximately 85%. On FrontierMath, a benchmark of original research-level mathematics problems, o3 scored 25.2% &mdash; problems that no previous AI could touch. But Chollet himself cautions: ARC-AGI measures program synthesis, not general intelligence. The mathematical debate rages: is a system that searches over a vast space of programs until it finds one that fits the data &ldquo;reasoning&rdquo;? Or does reasoning require something more &mdash; understanding <em>why</em> the program works? We will formalize both positions and see that the answer depends on your mathematical definition of reasoning &mdash; a definition we do not yet have.</p>
          <div class="lecture-topics">
            <h4>Key Themes</h4>
            <ul>
              <li>Chain-of-thought prompting: five words that changed AI performance</li>
              <li>CoT as additional computation: circuit complexity and transformer depth</li>
              <li>Process reward models vs. outcome reward models: rewarding the path, not just the answer</li>
              <li>Reward hacking: when AI finds shortcuts that bypass genuine reasoning</li>
              <li>Tree search over reasoning steps: the mathematical link to AlphaGo&rsquo;s MCTS</li>
              <li>OpenAI&rsquo;s o1 and o3: test-time reasoning at the frontier</li>
              <li>ARC-AGI and FrontierMath: benchmarks that probe genuine understanding</li>
              <li>The open question: what is the mathematical definition of &ldquo;reasoning&rdquo;?</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 33 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">33</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;When AI Solved the Hardest Math Competition: AlphaProof and the IMO&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Keynote</span>
          </div>
          <p class="lecture-abstract">In July 2024, at the International Mathematical Olympiad in Bath, England, a non-human contestant quietly earned the equivalent of a silver medal. Google DeepMind&rsquo;s AlphaProof solved four of the six competition problems, including a notoriously difficult number theory question. The sixth problem &mdash; a combinatorics puzzle that stumped most human competitors &mdash; took AlphaProof three full days of compute to crack. Mathematicians around the world took notice. Terence Tao, widely regarded as the greatest living mathematician, called the results &ldquo;very impressive.&rdquo; Timothy Gowers, a Fields Medalist, mused publicly about whether AI would soon surpass human mathematical ability. The age of machine mathematics had arrived &mdash; and the mathematics behind it is as deep as the problems it solved.<br><br><strong>Act One: Teaching AI to Prove.</strong> AlphaProof operates in the world of formal theorem proving, specifically in Lean 4 &mdash; a programming language where every mathematical statement has a machine-checkable proof. The key insight: if you can translate an IMO problem into Lean, then finding a solution becomes a <em>search problem</em> in the space of all valid proof steps. AlphaProof combines a language model (to propose proof steps) with reinforcement learning (to evaluate which steps lead toward complete proofs). Formally, each proof state is a node in a tree, each valid tactic application is an edge, and a complete proof is a path from root to a leaf labeled QED. The RL agent learns a value function $V(s)$ estimating the probability of reaching QED from state $s$, and a policy $\pi(a \mid s)$ over tactic actions. This is the same mathematical framework as AlphaGo &mdash; but instead of playing Go on a $19 \times 19$ board, the AI is playing mathematics on the infinite board of logical deduction.<br><br><strong>Act Two: A Hundred Million Geometry Problems.</strong> Alongside AlphaProof, DeepMind deployed AlphaGeometry 2 for the geometry problems. Its training strategy was breathtaking in scale: the team generated over 100 million synthetic geometry problems, each with a known solution, creating a vast training set without any human labeling. The generation process starts from random geometric configurations, derives all provable properties using a symbolic deduction engine, then pairs the hardest problems with their proofs. By January 2025, AlphaGeometry 2 could solve 83% of all historical IMO geometry problems &mdash; a superhuman performance level. The mathematical elegance lies in the architecture: a neural language model proposes auxiliary constructions (the creative &ldquo;add point $P$&rdquo; steps that make proofs possible), while a symbolic engine handles rigorous deduction. Creativity and rigor, unified.<br><br><strong>Act Three: Understanding vs. Proving.</strong> Here lies the philosophical heart of the lecture. AlphaProof can find a proof, but does it <em>understand</em> why the proof works? A human mathematician who solves an IMO problem develops intuition &mdash; a sense of why the result is true, how it connects to other mathematics, what generalizations might exist. AlphaProof has none of this. It searches a tree until it finds a path that works, much as a chess engine searches positions without understanding strategy. We will formalize the distinction: a proof is a syntactic object (a sequence of valid logical steps); understanding is a semantic object (a mental model that compresses the proof into insight). The open question for mathematics, and for humanity, is whether the gap between finding proofs and understanding proofs is a fundamental barrier &mdash; or a temporary limitation that future AI systems will overcome.</p>
          <div class="lecture-topics">
            <h4>Key Themes</h4>
            <ul>
              <li>AlphaProof at the IMO: four problems solved, a silver medal earned</li>
              <li>Formal theorem proving in Lean 4: mathematics as code</li>
              <li>Proof search as reinforcement learning: value functions and policies over tactic trees</li>
              <li>The AlphaGo-to-AlphaProof pipeline: from game boards to proof boards</li>
              <li>AlphaGeometry 2: 100 million synthetic problems and 83% of IMO geometry solved</li>
              <li>Neural creativity meets symbolic rigor: the hybrid architecture</li>
              <li>Proofs vs. understanding: the syntactic-semantic gap in machine mathematics</li>
              <li>Tao, Gowers, and the future: will AI surpass human mathematical ability?</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 34 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">34</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;The Hallucination Problem: When AI Confidently Says Wrong Things&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Keynote</span>
          </div>
          <p class="lecture-abstract">On a February morning in 2023, Google unveiled its new AI chatbot, Bard, to the world. In the promotional demo, Bard was asked about discoveries from the James Webb Space Telescope. It confidently stated that JWST took the very first pictures of a planet outside our solar system. This was wrong &mdash; the first exoplanet image was captured in 2004 by the Very Large Telescope in Chile. Within hours, Google&rsquo;s stock price dropped 9%, erasing roughly $100 billion in market value. A single hallucinated fact cost more than the GDP of most countries. Months later, a New York lawyer named Steven Schwartz submitted a court brief citing six legal precedents he had found using ChatGPT. The judge discovered that all six cases were fabrications &mdash; invented wholesale, complete with plausible case numbers and judicial opinions. Schwartz was sanctioned. These are not isolated incidents. They are symptoms of a deep mathematical problem at the heart of how language models work.<br><br><strong>Act One: Why Machines Hallucinate.</strong> A language model generates text by sampling from a probability distribution: at each step, the softmax function $p_i = e^{z_i} / \sum_j e^{z_j}$ converts raw scores into probabilities. The critical observation is that softmax <em>always</em> produces a confident-looking distribution &mdash; there is always a highest-probability token. The model cannot output &ldquo;I have no idea.&rdquo; Moreover, the training objective &mdash; minimizing cross-entropy $-\sum_t \log P(x_t \mid x_{&lt;t})$ &mdash; rewards fluency, not factual accuracy. A beautifully written paragraph about a nonexistent court case incurs the same loss as a beautifully written paragraph about a real one, as long as the word patterns are plausible. We will prove formally that cross-entropy minimization guarantees only that the model matches the statistical patterns of its training data, not that it distinguishes truth from falsehood.<br><br><strong>Act Two: The Mathematics of Honest Uncertainty.</strong> What would it take for a model to say &ldquo;I don&rsquo;t know&rdquo; reliably? This question leads to three deep mathematical frameworks. First, calibration: a well-calibrated model should be correct $p$ percent of the time when it reports confidence $p$. We will show that modern LLMs are spectacularly miscalibrated &mdash; they report 95% confidence when they are right only 60% of the time. Second, conformal prediction: a distribution-free framework that constructs prediction sets with guaranteed coverage. If we want 90% coverage, conformal prediction returns a set $C(x)$ such that $P(y \in C(x)) \geq 0.90$ &mdash; no distributional assumptions required. We will derive this guarantee from the elegant principle of exchangeability. Third, semantic entropy (2024): a new method that measures uncertainty not over individual tokens but over <em>meanings</em> &mdash; clustering semantically equivalent outputs and computing the entropy across clusters. If the model generates ten different answers that all mean the same thing, confidence is high; if it generates ten semantically distinct answers, uncertainty is high.<br><br><strong>Act Three: Can We Solve It?</strong> We close with the hardest question: is reliable hallucination detection even possible? Consider the task of determining whether a fluent, detailed paragraph about a historical event is true or fabricated. This requires access to ground truth &mdash; and for many domains, ground truth is ambiguous, contested, or simply unavailable. We will argue that for open-ended generation, perfect hallucination detection is at least as hard as general fact-checking &mdash; a problem with no known efficient solution. The connection to G&ouml;del&rsquo;s incompleteness theorem (Lecture 15) is tantalizing: just as no formal system can prove its own consistency, perhaps no language model can reliably detect its own hallucinations.</p>
          <div class="lecture-topics">
            <h4>Key Themes</h4>
            <ul>
              <li>Google Bard&rsquo;s $100 billion error and the lawyer who cited fake cases</li>
              <li>The softmax trap: why language models always sound confident</li>
              <li>Cross-entropy training: optimizing fluency, not truth</li>
              <li>Calibration: the gap between stated confidence and actual accuracy</li>
              <li>Conformal prediction: distribution-free coverage guarantees from exchangeability</li>
              <li>Semantic entropy: measuring uncertainty over meanings, not tokens</li>
              <li>The ground truth problem: why hallucination detection may be fundamentally hard</li>
              <li>Connections to G&ouml;del: can a model detect its own errors?</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 35 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">35</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;The Eyes of AI: How Machines Learned to See and Read at the Same Time&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Keynote</span>
          </div>
          <p class="lecture-abstract">In January 2021, OpenAI released two research papers on the same day. One introduced CLIP, a model that could classify images it had never seen by matching them to text descriptions. The other introduced DALL&middot;E, a model that could generate images from text prompts like &ldquo;an avocado-shaped armchair.&rdquo; Both depended on the same mathematical idea: projecting images and text into a shared vector space where meaning &mdash; visual and linguistic &mdash; could be measured by a dot product. This lecture tells the story of how AI learned to see and read simultaneously, and the mathematics that made multimodal intelligence possible.<br><br><strong>Act One: The Vision Transformer.</strong> For decades, convolutional neural networks (CNNs) dominated computer vision. Then in October 2020, Alexey Dosovitskiy and colleagues at Google Brain asked a heretical question: what if we threw away convolutions entirely and treated an image as a sequence of tokens? The Vision Transformer (ViT) chops an image into $16 \times 16$ pixel patches, flattens each patch into a vector, adds positional embeddings, and feeds the resulting sequence into a standard transformer. Mathematically, an image $\mathbf{I} \in \mathbb{R}^{H \times W \times 3}$ becomes a sequence $\mathbf{x}_1, \mathbf{x}_2, \ldots, \mathbf{x}_N$ where $N = HW/P^2$ and $P$ is the patch size. The self-attention mechanism then computes relationships between every pair of patches &mdash; allowing the model to learn that a dog&rsquo;s ear is related to its tail regardless of their spatial distance, something CNNs struggle with. We will derive the computational cost: $O(N^2 d)$ where $d$ is the embedding dimension, and see why this quadratic cost in the number of patches drives the need for efficient attention.<br><br><strong>Act Two: Connecting Vision and Language.</strong> CLIP (Contrastive Language-Image Pre-training) trains a vision encoder and a text encoder simultaneously on 400 million image-text pairs scraped from the internet. The training objective is contrastive: given a batch of $n$ image-text pairs, maximize the cosine similarity $\text{sim}(v_i, t_i)$ for matched pairs while minimizing $\text{sim}(v_i, t_j)$ for $i \neq j$. The loss function is a symmetric cross-entropy over the $n \times n$ similarity matrix. The result is a shared embedding space where images and text coexist &mdash; you can search for images using text, classify images using descriptions of categories the model has never seen (&ldquo;zero-shot classification&rdquo;), and measure the semantic distance between a photograph and a poem. We will compute CLIP&rsquo;s zero-shot accuracy and show that it matches supervised models trained on millions of labeled examples &mdash; without seeing a single label.<br><br><strong>Act Three: The Diffusion Revolution.</strong> DALL&middot;E, Midjourney, and Stable Diffusion generate images from text using a mathematical process called diffusion. The forward process systematically destroys an image by adding Gaussian noise: $x_t = \sqrt{\alpha_t}\, x_0 + \sqrt{1 - \alpha_t}\, \epsilon$ where $\epsilon \sim \mathcal{N}(0, I)$ and $\alpha_t$ decreases toward zero. After $T$ steps, the image is pure noise. The reverse process learns to undo this destruction: a neural network $\epsilon_\theta(x_t, t)$ predicts the noise at each step, and we iteratively denoise to recover the image. The mathematical beauty is that the reverse process is also a diffusion &mdash; running backward in time &mdash; and the training objective reduces to a simple mean-squared error: $L = \mathbb{E}_{t, x_0, \epsilon}[\|\epsilon - \epsilon_\theta(x_t, t)\|^2]$. Text conditioning enters through cross-attention: the text embedding from CLIP becomes the keys and values, while the image features are the queries. In 2024, Sora extended this to video generation, treating time as a third spatial dimension. And by 2025, flow matching &mdash; a new mathematical framework that replaces the stochastic diffusion process with deterministic optimal transport paths &mdash; is emerging as the next paradigm, offering faster generation with cleaner mathematical foundations.</p>
          <div class="lecture-topics">
            <h4>Key Themes</h4>
            <ul>
              <li>The Vision Transformer: treating images as sequences of patch tokens</li>
              <li>CLIP: contrastive learning to build a shared vision-language embedding space</li>
              <li>Zero-shot classification: matching supervised accuracy without labels</li>
              <li>Diffusion models: the forward noise process and the learned reverse denoising</li>
              <li>Cross-modal attention: text as keys/values, image features as queries</li>
              <li>Sora and video generation: extending diffusion to the temporal dimension</li>
              <li>Flow matching: deterministic optimal transport replacing stochastic diffusion</li>
              <li>The multimodal future: when AI sees, reads, and creates simultaneously</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 36 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">36</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;Looking Inside the Black Box: The Mathematics of AI Interpretability&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Keynote</span>
          </div>
          <p class="lecture-abstract">In May 2024, researchers at Anthropic published a remarkable finding. Deep inside Claude &mdash; a large language model with billions of parameters &mdash; they found individual features that correspond to recognizable concepts. One feature activates specifically for the Golden Gate Bridge. When the researchers artificially amplified this feature, Claude became obsessed: it would steer every conversation toward the bridge, describe itself as the bridge, and refuse to discuss anything else. &ldquo;Golden Gate Claude&rdquo; became an internet sensation &mdash; but behind the joke lay a profound scientific breakthrough. For the first time, researchers could point to a specific direction in a neural network&rsquo;s activation space and say: <em>this</em> is what the model is thinking about. The black box had cracked open, and mathematics was the crowbar.<br><br><strong>Act One: The Alignment Problem.</strong> Before we can interpret a model, we must understand why it behaves as it does. Modern language models are trained in three stages. First, pre-training on internet text produces a base model that can complete any text pattern. Second, supervised fine-tuning teaches the model to follow instructions. Third &mdash; and most crucially &mdash; Reinforcement Learning from Human Feedback (RLHF) aligns the model with human preferences. The mathematical objective is: $\max_\pi \mathbb{E}_{x \sim D}\left[\mathbb{E}_{y \sim \pi(\cdot|x)}[r(x,y)] - \beta \, \text{KL}(\pi \| \pi_{\text{ref}})\right]$ where $\pi$ is the policy (the model&rsquo;s behavior), $r(x,y)$ is a learned reward function, $\pi_{\text{ref}}$ is the pre-trained base model, and $\beta$ controls how far the aligned model can drift from the base. The KL divergence penalty is essential: without it, the model collapses to producing a single high-reward response regardless of the input. We will derive why this objective is equivalent to sampling from a Boltzmann distribution $\pi^*(y|x) \propto \pi_{\text{ref}}(y|x) \, e^{r(x,y)/\beta}$ &mdash; connecting alignment to statistical physics once again.<br><br><strong>Act Two: Superposition and Sparse Autoencoders.</strong> A large language model has, say, 10,000 neurons per layer. But the number of meaningful concepts in the world &mdash; places, people, ideas, relationships &mdash; is vastly larger. The superposition hypothesis proposes that neural networks solve this mismatch by encoding far more features than they have dimensions, at the cost of slight interference between features. Mathematically, this is compressed sensing: a vector $\mathbf{x} \in \mathbb{R}^d$ can encode $m \gg d$ sparse features if most features are inactive at any given time. Sparse autoencoders (SAEs) reverse this compression. An SAE learns an encoder $f(\mathbf{x}) = \text{ReLU}(W_e \mathbf{x} + b_e)$ that maps activations to a high-dimensional sparse representation, and a decoder $g(\mathbf{z}) = W_d \mathbf{z} + b_d$ that reconstructs the original activations. The sparsity constraint forces each dimension of $\mathbf{z}$ to correspond to a single interpretable feature. This is how the Golden Gate Bridge feature was found &mdash; it was a single dimension in the SAE&rsquo;s output that activated precisely when bridge-related content appeared.<br><br><strong>Act Three: Constitutional AI and the Future of Alignment.</strong> Anthropic&rsquo;s Constitutional AI takes a different approach: instead of human labelers, AI itself provides the feedback. A set of principles (&ldquo;be helpful, be harmless, be honest&rdquo;) serves as a constitution, and the model critiques and revises its own outputs according to these principles. Mathematically, this replaces the human reward model $r(x,y)$ with a model-generated reward $r_{\text{AI}}(x,y|\text{constitution})$, creating a recursive alignment process. We will formalize the conditions under which this self-supervised alignment converges and examine the open question that keeps alignment researchers awake at night: can we ever fully understand what a model with hundreds of billions of parameters &ldquo;knows&rdquo; and &ldquo;wants&rdquo;? The mathematics of interpretability is not just an academic exercise &mdash; it is the safety engineering of the most powerful technology humanity has ever built.</p>
          <div class="lecture-topics">
            <h4>Key Themes</h4>
            <ul>
              <li>Golden Gate Claude: finding and amplifying individual features inside a neural network</li>
              <li>RLHF: the mathematical objective for aligning AI with human preferences</li>
              <li>The KL divergence penalty: why alignment needs a leash to the base model</li>
              <li>The superposition hypothesis: more concepts than neurons, solved by sparsity</li>
              <li>Sparse autoencoders: reversing the compression to find interpretable features</li>
              <li>Constitutional AI: using principles instead of human labelers for alignment</li>
              <li>The Boltzmann connection: alignment as sampling from an energy-based distribution</li>
              <li>The open question: can we fully understand what a billion-parameter model knows?</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 37 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">37</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;How Machines Read Numbers: The Surprising Mathematics of Tokenization&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Keynote</span>
          </div>
          <p class="lecture-abstract">Ask GPT-4 whether 9.11 is greater than 9.9, and it will confidently tell you that 9.11 is larger. It is wrong. Ask it to reverse the string &ldquo;lollipop&rdquo; and it will stumble. Ask it to count the number of &ldquo;r&rdquo; letters in &ldquo;strawberry&rdquo; and it may answer two instead of three. These failures are not random bugs &mdash; they are systematic consequences of a mathematical design choice made before any training begins: tokenization. The way a language model carves text into pieces determines what it can and cannot see. And for numbers, this carving is catastrophically wrong.<br><br><strong>Act One: The Byte Pair Encoding Algorithm.</strong> Modern language models do not read characters or words. They read <em>tokens</em> &mdash; subword units produced by an algorithm called Byte Pair Encoding (BPE), invented by Philip Gage in 1994 for data compression, not for AI. BPE starts with individual bytes and iteratively merges the most frequent adjacent pair into a new token. After $V$ merges, you have a vocabulary of size $V + 256$ (the original bytes plus $V$ merged tokens). We will run BPE by hand on a small corpus and watch the vocabulary grow. The result is a codebook that encodes common words as single tokens (&ldquo;the&rdquo; &rarr; one token) but splits rare words into fragments (&ldquo;cryptography&rdquo; &rarr; three or four tokens). Crucially, numbers receive no special treatment: &ldquo;123456&rdquo; might become [&ldquo;123&rdquo;, &ldquo;456&rdquo;] or [&ldquo;12&rdquo;, &ldquo;345&rdquo;, &ldquo;6&rdquo;] depending on what appeared frequently in the training data. The model literally cannot see the digit structure that makes arithmetic possible.<br><br><strong>Act Two: The Information Theory of Tokenization.</strong> Tokenization is, at its mathematical core, a compression problem. Shannon&rsquo;s source coding theorem tells us that the optimal encoding of a source with entropy $H$ requires at least $H$ bits per symbol. BPE approximates this by assigning shorter codes (single tokens) to frequent patterns and longer codes (multiple tokens) to rare patterns. The model&rsquo;s probability distribution $P(\text{token}_t \mid \text{token}_{1:t-1})$ operates over this compressed representation, which means the model is predicting compressed symbols, not raw text. We will compute the compression ratio of BPE on English text (approximately 3.5&ndash;4 characters per token) and see why this ratio is remarkably close to the entropy rate of English estimated by Shannon in 1951. The deep insight: a language model&rsquo;s perplexity is directly related to how well it compresses its input, and compression ratio is a measure of &ldquo;understanding&rdquo; &mdash; the better you understand a language, the better you can compress it.<br><br><strong>Act Three: Beyond Tokens.</strong> What if we skipped tokenization entirely? In 2024, Meta released the Byte Latent Transformer (BLT), which operates directly on raw bytes &mdash; no vocabulary, no merging, no tokenizer. Each byte (0&ndash;255) is an input. The challenge is efficiency: byte sequences are 3&ndash;4 times longer than token sequences, and attention cost scales quadratically. BLT solves this by dynamically grouping bytes into patches of variable length, with boundaries determined by the model itself based on local entropy estimates. When the next byte is predictable (within a common word), the patch grows longer; when uncertainty spikes (at word boundaries, code syntax), the patch breaks. The mathematical elegance is that the model learns its own segmentation &mdash; an optimal tokenization emerging from the data rather than imposed by a preprocessing algorithm. For finance, the implications are direct: when a trading algorithm reads the price &ldquo;9.11&rdquo; and needs to compare it to &ldquo;9.9&rdquo;, the tokenization matters more than the model&rsquo;s training. Getting this wrong can mean the difference between a profitable trade and a catastrophic one.</p>
          <div class="lecture-topics">
            <h4>Key Themes</h4>
            <ul>
              <li>Why GPT-4 thinks 9.11 &gt; 9.9: the tokenization trap for numbers</li>
              <li>Byte Pair Encoding: the 1994 compression algorithm now powering every LLM</li>
              <li>Running BPE by hand: watching a vocabulary emerge from raw frequency counts</li>
              <li>Shannon&rsquo;s source coding theorem and the information theory of tokenization</li>
              <li>Compression as understanding: perplexity, entropy rate, and what models &ldquo;know&rdquo;</li>
              <li>Meta&rsquo;s Byte Latent Transformer: skipping tokenization with dynamic byte patches</li>
              <li>The financial cost: when your trading bot cannot compare prices correctly</li>
              <li>The open question: is learned segmentation the future of language modeling?</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 38 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">38</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;The Mixture of Experts: How AI Learned to Think with Different Brains&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Keynote</span>
          </div>
          <p class="lecture-abstract">In December 2023, a tiny French startup called Mistral AI &mdash; founded just seven months earlier by former Google DeepMind and Meta researchers &mdash; released a model called Mixtral 8x7B. It had the quality of GPT-3.5 but ran at a fraction of the cost. The secret was not a better training recipe or more data. It was a mathematical architecture called Mixture of Experts that had been invented thirty years earlier and mostly forgotten. Mixtral proved that you do not need to activate every parameter for every input &mdash; you just need to activate the <em>right</em> parameters. This lecture tells the story of how an old idea became the most important architectural innovation in modern AI.<br><br><strong>Act One: The Gating Function.</strong> The Mixture of Experts (MoE) architecture replaces a single large feed-forward network with $K$ smaller &ldquo;expert&rdquo; networks and a gating function that decides which experts to consult for each input. Given an input $\mathbf{x}$, the gating function computes $G(\mathbf{x}) = \text{softmax}(W_g \cdot \mathbf{x})$, producing a probability distribution over all $K$ experts. Only the top-$k$ experts (typically $k = 2$) are activated, and their outputs are combined: $y = \sum_{i \in \text{top-}k} G_i(\mathbf{x}) \cdot E_i(\mathbf{x})$ where $E_i$ is the $i$-th expert network. This means a model with 47 billion total parameters (Mixtral&rsquo;s 8 experts of ~7B each, minus shared layers) uses only about 13 billion parameters per input &mdash; achieving the quality of a dense 47B model at the inference cost of a 13B model. We will derive the computational savings formally: for a dense model, each token requires $O(d \cdot d_{\text{ff}})$ FLOPs in the feed-forward layers; for MoE with $K$ experts and top-$k$ routing, this drops to $O(k \cdot d \cdot d_{\text{ff}} / K)$ &mdash; a factor of $K/k$ savings.<br><br><strong>Act Two: The Load Balancing Problem.</strong> There is a catch. If the gating function sends all inputs to the same expert, MoE degenerates into a single small model. This &ldquo;expert collapse&rdquo; is the central mathematical challenge of MoE architectures. The solution is an auxiliary loss that penalizes uneven routing: $L_{\text{balance}} = \alpha \cdot K \cdot \sum_{i=1}^{K} f_i \cdot p_i$ where $f_i$ is the fraction of tokens routed to expert $i$ and $p_i$ is the average gating probability for expert $i$. When all experts receive equal traffic, $f_i = 1/K$ and $p_i = 1/K$, so $L_{\text{balance}} = \alpha$. Any deviation increases the loss. We will prove that this auxiliary loss has a unique minimum at uniform distribution and analyze its gradient: the balancing signal is proportional to the <em>covariance</em> between routing frequency and gating probability, providing an elegant feedback mechanism. But load balancing is not just a mathematical curiosity &mdash; it is an engineering nightmare. On distributed systems with thousands of GPUs, routing tokens to the correct expert across devices requires all-to-all communication, creating network bottlenecks that can erase the computational savings.<br><br><strong>Act Three: From Mistral to DeepSeek to the Brain.</strong> In early 2025, DeepSeek &mdash; a Chinese AI laboratory &mdash; released DeepSeek-V3 and DeepSeek-R1, MoE models that sent shockwaves through the AI industry. Their innovation was fine-grained experts: instead of 8 large experts, they used 256 small experts with a handful of &ldquo;shared&rdquo; experts that activate for every input. The shared experts handle common knowledge (grammar, facts), while the routed experts specialize in domains (code, mathematics, poetry). This mirrors how the human brain works: Broca&rsquo;s area specializes in language production, the visual cortex specializes in image processing, the hippocampus specializes in memory &mdash; but all regions share a common communication infrastructure. We will formalize this analogy using the mathematical framework of modular networks and ask the deepest question in MoE research: is there an optimal number of experts? Information theory suggests that the answer depends on the intrinsic dimensionality of the task distribution &mdash; a quantity we do not yet know how to measure. The mathematics of specialization and generalization, it turns out, is still wide open.</p>
          <div class="lecture-topics">
            <h4>Key Themes</h4>
            <ul>
              <li>Mistral and Mixtral: how a startup challenged AI giants with an old idea</li>
              <li>The MoE architecture: gating functions, top-$k$ routing, and sparse computation</li>
              <li>Computational savings: $K/k$ factor reduction in FLOPs with formal derivation</li>
              <li>The load balancing problem: auxiliary losses, expert collapse, and the uniform optimum</li>
              <li>Google&rsquo;s Switch Transformer: scaling to trillions of parameters</li>
              <li>DeepSeek&rsquo;s fine-grained experts: 256 specialists plus shared generalists</li>
              <li>The neuroscience analogy: Broca&rsquo;s area, visual cortex, and modular computation</li>
              <li>The open question: what is the optimal number of experts?</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- ==================== LECTURE 39 ==================== -->
      <div class="lecture-card">
        <div class="lecture-number">39</div>
        <div class="lecture-content">
          <h3 class="lecture-title">&ldquo;Beyond the Transformer: The Mathematics of What Comes Next&rdquo;</h3>
          <div class="lecture-meta">
            <span class="lecture-duration">45 min</span>
            <span class="lecture-level">Keynote</span>
          </div>
          <p class="lecture-abstract">The transformer has been the undisputed king of AI since June 2017, when eight Google researchers published &ldquo;Attention Is All You Need&rdquo; and changed computing forever. GPT-4, Claude, Gemini, LLaMA &mdash; every frontier model uses some variant of the same architecture. But the transformer has a fatal mathematical flaw: self-attention computes a score between every pair of tokens, giving it a time and memory cost of $O(n^2)$ in the sequence length $n$. Process a 100,000-token document and you need ten billion pairwise scores. This quadratic bottleneck is not merely inconvenient &mdash; it is an existential threat to scaling. And in 2023, a young researcher named Albert Gu proposed a radical alternative that works in $O(n)$ time. The race to replace the transformer has begun.<br><br><strong>Act One: State Space Models and Mamba.</strong> Albert Gu&rsquo;s insight was to revive a classical mathematical framework: state space models (SSMs). A continuous-time SSM is defined by the equations $h&rsquo;(t) = A\,h(t) + B\,x(t)$ and $y(t) = C\,h(t)$ where $h(t) \in \mathbb{R}^d$ is a hidden state, $x(t)$ is the input, $y(t)$ is the output, and $A, B, C$ are learnable matrices. This is the mathematics of control theory and signal processing, developed decades before deep learning. The discretization trick converts these continuous equations to discrete sequences: $h_k = \bar{A}\,h_{k-1} + \bar{B}\,x_k$ where $\bar{A}$ and $\bar{B}$ are obtained from $A$ and $B$ via the zero-order hold: $\bar{A} = e^{A\Delta}$ and $\bar{B} = (e^{A\Delta} - I)A^{-1}B$ with $\Delta$ being the step size. The resulting discrete recurrence processes each token in constant time, giving $O(n)$ total cost. But there is a subtlety: for training, we need to process all tokens in parallel. Gu showed that the discrete SSM can be rewritten as a convolution: $y = \bar{K} * x$ where $\bar{K} = (C\bar{B}, C\bar{A}\bar{B}, C\bar{A}^2\bar{B}, \ldots)$ is a convolution kernel, computable in $O(n \log n)$ using the FFT. Mamba (December 2023) added a crucial innovation: making the parameters $B$, $C$, and $\Delta$ <em>input-dependent</em> &mdash; the selective scan mechanism that allows the model to decide, for each token, what information to store and what to forget.<br><br><strong>Act Two: Making Attention Efficient.</strong> While Mamba attacked the transformer&rsquo;s architecture, Tri Dao attacked its implementation. Flash Attention (2022) observed that the $O(n^2)$ memory cost of attention is not inherent to the mathematics &mdash; it is an artifact of how GPUs are programmed. Standard attention computes the full $n \times n$ attention matrix, storing it in high-bandwidth memory (HBM). Flash Attention tiles the computation into blocks that fit in fast SRAM, never materializing the full matrix. The mathematical trick is to decompose the softmax computation into blocks using the online softmax algorithm, maintaining running statistics $m_i$ (running max) and $\ell_i$ (running sum) that allow exact computation without storing all scores. The result: attention that is mathematically identical but uses $O(n)$ memory instead of $O(n^2)$, and runs 2&ndash;4 times faster by reducing memory transfers. Ring Attention (2023) extends this to multiple devices: each GPU holds a segment of the sequence and passes key-value blocks around a ring topology, enabling effectively infinite context lengths distributed across a cluster. These engineering breakthroughs mean the transformer may yet survive by making its quadratic attention <em>feel</em> linear in practice.<br><br><strong>Act Three: The Compute Cost Crisis.</strong> We close with the question that looms over all of AI: can we afford the mathematics? Training GPT-4 consumed roughly $100 million in compute. Inference costs for ChatGPT exceed billions of dollars per year. The Jevons paradox &mdash; named after the 19th-century economist William Stanley Jevons who observed that more efficient coal engines led to <em>more</em> coal consumption, not less &mdash; haunts AI: every efficiency improvement (Flash Attention, MoE, quantization) gets immediately consumed by running bigger models on longer contexts. A single GPT-4 query uses approximately 10 watt-hours of energy, while a Google search uses 0.3 watt-hours. RWKV, a volunteer-driven open-source project, has proven that linear-time language models can approach transformer quality, suggesting that the quadratic cost is not fundamental. But whether the next revolution comes from new architectures (SSMs, linear attention), new mathematics (flow matching, energy-based models), or new hardware (optical computing, neuromorphic chips), one thing is certain: the transformer will not be the last word. The history of mathematics teaches us that every dominant paradigm eventually yields to a more elegant successor &mdash; and the mathematics of what comes next is being written right now.</p>
          <div class="lecture-topics">
            <h4>Key Themes</h4>
            <ul>
              <li>The transformer&rsquo;s $O(n^2)$ bottleneck: why quadratic attention cannot scale forever</li>
              <li>State space models: control theory as the foundation for linear-time sequence modeling</li>
              <li>Mamba&rsquo;s selective scan: input-dependent parameters and the discretization trick</li>
              <li>Flash Attention: IO-aware tiling that makes quadratic attention feel linear</li>
              <li>Ring Attention: distributing infinite contexts across device clusters</li>
              <li>RWKV: volunteer-driven proof that linear models compete with transformers</li>
              <li>The Jevons paradox in AI: more efficiency leads to more consumption, not less</li>
              <li>The open question: will the next revolution be a new architecture or new mathematics?</li>
            </ul>
          </div>
        </div>
      </div>

    </div>
  </section>

  <!-- ========== FOOTER ========== -->
  <footer>
    <div class="footer-content">
      <p><a href="https://github.com/Digital-AI-Finance" target="_blank" rel="noopener noreferrer">Digital-AI-Finance</a></p>
      <p>2026 &mdash; How Math Powers AI in Everyday Finance</p>
    </div>
  </footer>

  <!-- KaTeX JS -->
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

  <!-- Shared JS (includes KaTeX auto-render initialization) -->
  <script src="js/main.js"></script>
</body>
</html>
